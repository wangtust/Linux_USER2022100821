# 关于ssh每次连接虚拟机的linux都要输密码，好烦
可以找到linux位于.ssh文件夹里的authorized_keys，用vim插入mac的ssh密钥就OK
哈哈哈，试了下果然成功了

# 什么是linux终端？有哪几种类型？
Linux终端，也被称为命令行界面（Command Line Interface，CLI），是用户与Linux系统交互的一种方式。用户可以在终端中输入命令，然后由系统执行这些命令。终端是Linux系统的核心组成部分，许多任务可以通过在终端中输入相应的命令来完成。

Linux终端有多种类型，以下是一些常见的：

1. **Bash**：Bash是Bourne Again Shell的缩写，是最常见的Linux shell。它由GNU项目开发，是许多Linux发行版的默认shell。

2. **Sh**：Sh是Bourne Shell的缩写，是最早的Unix Shell之一。Bash就是基于Sh进行开发的。

3. **Ksh**：Ksh是Korn Shell的缩写，由AT&T Bell Laboratories开发。它包含了C Shell和Bourne Shell的许多特性。

4. **Csh**：Csh是C Shell的缩写，其语法与C语言类似。它由Bill Joy开发，是许多早期Unix系统的默认shell。

5. **Tcsh**：Tcsh是C Shell的一个增强版本，提供了命令行编辑、命令历史等功能。

6. **Zsh**：Zsh是Z Shell的缩写，是一个强大的shell，提供了许多高级功能，如命令行提示、拼写检查、更强大的编程能力等。

7. **Fish**：Fish是Friendly Interactive Shell的缩写，是一个用户友好的shell，提供了自动建议、颜色编码等功能。

每种shell都有其特点和优势，用户可以根据自己的需求和喜好选择使用哪种shell。

这是一个Linux系统中的`/dev/tty*`设备列表。在Linux中，`/dev`目录包含了所有的设备文件。这些设备文件代表了系统中的各种设备，包括硬件设备（如硬盘、鼠标、键盘等）和虚拟设备（如/dev/null、/dev/random等）。

在这个列表中，`/dev/tty`、`/dev/tty0`、`/dev/tty1`等是终端设备文件。`tty`是Teletype的缩写，这些设备通常用于用户和系统的交互。

`/dev/ttyS0`、`/dev/ttyS1`等是串行端口设备文件。`ttyS`是Serial的缩写，这些设备通常用于串行通信。

每个设备文件前面的`crw-------`表示这个设备文件的类型和权限。`c`表示这是一个字符设备文件，`r`表示可读，`w`表示可写，`-`表示不可执行。后面的两个数字是设备的主设备号和次设备号。

这个列表是通过`ll /dev/tty*`命令获取的。`ll`是`ls -l`的别名，用于列出目录中的文件和目录，包括它们的详细信息。`/dev/tty*`是一个通配符，匹配`/dev`目录下所有以`tty`开头的文件和目录。

# Linux 用户
在Linux系统中，`/etc/passwd`文件中的每一行都代表一个用户，其中第一字段就是用户名。你看到的`USER2022100821`就是你创建的用户。

除了你创建的用户外，Linux系统还会自动创建一些系统用户，用于运行系统服务和进行系统管理。这些用户包括`root`（超级用户）、`daemon`（用于运行守护进程的用户）、`bin`（用于管理二进制文件的用户）等。

所以，虽然你只创建了一个用户`USER2022100821`，但是系统中还有其他的系统用户，所以`/etc/passwd`文件中会有多行。
## 查看用户和组
在 Unix 和 Unix-like 的操作系统中，你可以使用以下命令来查看系统中的所有用户和他们所属的组：

1. 查看所有用户：`cut -d: -f1 /etc/passwd`。这个命令会显示 `/etc/passwd` 文件中的所有用户。`/etc/passwd` 文件包含了系统中所有用户的信息。

2. 查看用户所属的组：`groups username`。这个命令会显示用户 `username` 所属的所有组。你需要将 `username` 替换为你想要查询的用户名。

请注意，这些命令需要在终端中运行。如果你想要查看所有用户和他们所属的组，你可能需要编写一个脚本，遍历所有用户并调用 `groups` 命令。

```bash
for user in $(cut -d: -f1 /etc/passwd); do
  echo -n "$user : "
  groups $user
done
```

这个脚本会遍历 `/etc/passwd` 文件中的所有用户，然后对每个用户调用 `groups` 命令，显示用户所属的所有组。
### 怎么编写脚本
在 Linux 系统中，你可以使用 Bash（Bourne Again Shell）来编写脚本。Bash 是一种常见的 shell，它提供了许多用于编写脚本的功能。

以下是一个简单的 Bash 脚本示例，该脚本会遍历系统中的所有用户，并显示他们所属的所有组：

```bash
#!/bin/bash

# 遍历 /etc/passwd 文件中的所有用户
for user in $(cut -d: -f1 /etc/passwd); do
  # 显示用户名
  echo -n "$user : "
  # 显示用户所属的所有组
  groups $user
done
```

这个脚本的第一行 `#!/bin/bash` 是一个特殊的行，被称为 shebang。它告诉系统这个脚本应该使用哪种 shell 来执行。

你可以将这个脚本保存为一个文件，例如 `list_users_and_groups.sh`，然后使用 `chmod +x list_users_and_groups.sh` 命令来给这个文件添加执行权限。然后，你就可以使用 `./list_users_and_groups.sh` 命令来运行这个脚本了。
### 在终端编写脚本

在终端中，你可以使用文本编辑器（如 vim、nano 或 emacs）来编写脚本。以下是一个使用 vim 编辑器创建并编写 Bash 脚本的例子：

1. 打开终端。

2. 输入 `vim script.sh` 并按回车。这将使用 vim 编辑器创建一个名为 `script.sh` 的新文件。

3. 在 vim 编辑器中，按 `i` 进入插入模式。

4. 输入你的脚本内容，例如：

```bash
#!/bin/bash

echo "Hello, world!"
```

5. 按 `Esc` 退出插入模式。

6. 输入 `:wq` 并按回车，保存并退出 vim 编辑器。

7. 输入 `chmod +x script.sh` 并按回车，给脚本添加执行权限。

8. 输入 `./script.sh` 并按回车，运行脚本。

以上步骤创建了一个简单的 Bash 脚本，这个脚本会打印 "Hello, world!"。你可以根据需要修改脚本的内容。
# 关于终端的命令
`ps -efj`是一个在Linux系统中查看进程信息的命令。这个命令的输出包含了系统中所有进程的详细信息。下面是这个命令各个选项的含义：

- `ps`：这是Process Status的缩写，用于查看进程状态。
- `-e`：这是Every的缩写，表示列出系统中的所有进程。
- `-f`：这是Full format的缩写，表示以完整格式显示进程信息。完整格式包括了UID、PID、PPID、C、STIME、TTY、TIME和CMD等字段。
- `-j`：这是Job format的缩写，表示以作业格式显示进程信息。作业格式包括了额外的PGID和SID字段，分别表示进程组ID和会话ID。

这个命令的输出可以帮助你了解系统中正在运行的进程的状态，包括它们的PID、父进程ID、进程组ID、会话ID、用户ID、开始时间、终端、CPU时间和命令等信息。
### usr_grp.sh
```bash
 #!/bin/bash

# 遍历 /etc/passwd 文件中的所有用户
for user in $(cut -d: -f1 /etc/passwd); do
  # 显示用户名
  echo -n "$user : "
  # 显示用户所属的所有组
  groups $user
done
```
这个输出是你运行 `usr_grp.sh` 脚本的结果，该脚本列出了你的系统中的所有用户及其所属的组。每一行的格式为 `username : username : group1 group2 ...`。

例如，对于输出的最后一行 `USER2022100821 : USER2022100821 : USER2022100821 sudo`，这表示有一个名为 `USER2022100821` 的用户，他属于 `USER2022100821` 和 `sudo` 这两个组。

这个脚本的工作原理是遍历 `/etc/passwd` 文件中的所有用户，然后对每个用户调用 `groups` 命令，显示用户所属的所有组。
### Bash 
Bash 是 "Bourne-Again SHell" 的缩写，这个名字是对 "Bourne Shell"（sh）的一种玩笑式的致敬，因为 Bash 是 Bourne Shell 的替代品，并且增加了许多新的特性。

Bash 是一个命令解释器，也是 Unix 和 Linux 系统中默认的 shell。它允许用户与操作系统进行交互，执行命令，或者运行脚本。

Bash 的主要功能包括：

- 命令行编辑：Bash 提供了许多命令行编辑的功能，如命令历史和命令补全。
- 脚本编程：Bash 支持变量、函数、控制结构（如 if-then-else 和循环）等编程特性，可以用来编写复杂的脚本。
- 作业控制：Bash 支持前台和后台作业，以及作业控制命令（如 `bg`、`fg` 和 `jobs`）。

Bash 的基本语法包括：

- 命令：在 Bash 中，你可以输入命令，然后按回车键执行。命令可以是内建的 Bash 命令，也可以是系统命令或者用户自定义的脚本。
- 变量：在 Bash 中，你可以使用 `=` 来赋值，使用 `$` 来引用变量，例如 `var="Hello, world!"` 和 `echo $var`。
- 控制结构：Bash 支持 `if`、`for`、`while` 等控制结构，用来编写条件判断和循环。
- 函数：在 Bash 中，你可以使用 `function` 关键字来定义函数，例如 `function greet { echo "Hello, $1!"; }`。

以上是 Bash 的基本介绍和语法，你可以根据需要深入学习 Bash 的更多特性和用法。
以下是一个简单的 Bash 脚本示例，它包含了变量、控制结构和函数等基本语法：

```bash
#!/bin/bash

# 定义一个函数
function greet {
  echo "Hello, $1!"
}

# 定义一个变量
greeting="Hello, world!"

# 打印变量
echo $greeting

# 使用 if-then-else 结构
if [ "$greeting" == "Hello, world!" ]; then
  echo "Greeting is correct."
else
  echo "Greeting is incorrect."
fi

# 使用 for 循环
for name in Alice Bob Charlie; do
  greet $name
done
```

这个脚本首先定义了一个函数 `greet`，然后定义了一个变量 `greeting` 并打印出来。然后，脚本使用 if-then-else 结构检查 `greeting` 变量的值是否正确。最后，脚本使用 for 循环调用 `greet` 函数，为 Alice、Bob 和 Charlie 打招呼。
# key.c
这个程序是一个在Linux终端中读取按键值的程序。它使用了termios库来改变终端的行为。以下是对程序的详细分析：

1. `struct termios old_attrs, new_attrs;`：定义了两个termios结构体变量，用于保存终端的属性。

2. `tcgetattr(STDIN_FILENO, &old_attrs);`：获取当前终端的属性，并保存在old_attrs中。

3. `new_attrs = old_attrs;`：将当前终端的属性复制到new_attrs中。

4. `new_attrs.c_cc[VTIME] = 0; new_attrs.c_cc[VMIN] = 0;`：设置终端的读取行为。VTIME是读取的超时时间，VMIN是读取的最小字符数。这里都设置为0，表示read操作是非阻塞的。

5. `new_attrs.c_lflag &= ~(ICANON | ECHO);`：关闭规范模式（ICANON）和回显（ECHO）。规范模式下，终端会缓存输入，直到遇到换行或EOF才发送给程序；回显是指在终端上显示输入的字符。

6. `tcsetattr(STDIN_FILENO, TCSANOW, &new_attrs);`：立即改变终端的属性。

7. `printf("Press any key. Press 'q' to quit.\n");`：打印提示信息。

8. 在while循环中，使用`read(STDIN_FILENO, c_in, 3);`读取终端的输入。因为设置了非阻塞和非规范模式，所以这个操作会立即返回，不论是否有输入。如果有输入，它会返回读取的字符数，并将字符保存在c_in中。

9. `if (c_in[0] == 'q') { break; }`：如果读取到'q'字符，退出循环。

10. `tcsetattr(STDIN_FILENO, TCSANOW, &old_attrs);`：在程序结束前，恢复终端的原始属性。

这个程序的主要作用是读取并打印终端的按键值，直到用户按下'q'键。在读取按键值的过程中，它改变了终端的行为，使得读取操作是非阻塞的，并且关闭了规范模式和回显。
# 原始（nonblock）输入
原始输入（nonblock）是指在读取输入时，不会阻塞程序的执行。在默认情况下，当你调用读取输入的函数（如`read`或`getchar`）时，如果没有可用的输入，这些函数会阻塞，即暂停程序的执行，直到有输入可读。

然而，你可以通过设置终端的属性，使得读取操作变为非阻塞的。在非阻塞模式下，读取函数会立即返回，不论是否有输入。如果有输入，它会返回读取的字符数；如果没有输入，它会返回0。

在你的程序中，你通过设置`new_attrs.c_cc[VTIME] = 0; new_attrs.c_cc[VMIN] = 0;`来实现非阻塞读取。这两个设置分别表示读取的超时时间和最小字符数。当它们都设置为0时，`read`函数会立即返回，不论是否有输入。
# keys.c
这段代码是一个使用ncurses库创建的文本用户界面程序。它显示了一个菜单，用户可以使用上下箭头键在菜单项之间移动，按Enter键选择一个菜单项。

以下是对程序的详细分析：

1. `initscr();`：初始化ncurses模式。

2. `clear();`：清除屏幕。

3. `noecho();`：关闭回显。在这种模式下，输入的字符不会被显示在屏幕上。

4. `cbreak();`：关闭行缓冲。在这种模式下，输入的字符会立即被程序读取，而不是等待用户按下Enter键。

5. `menu_win = newwin(HEIGHT, WIDTH, starty, startx);`：创建一个新的窗口，用于显示菜单。

6. `keypad(menu_win, TRUE);`：允许窗口捕获特殊键值，如箭头键。

7. 在while循环中，使用`wgetch(menu_win);`读取用户的输入。根据输入的键值，更新高亮的菜单项，或者设置用户的选择。

8. `print_menu(menu_win, highlight);`：打印菜单。高亮的菜单项会被反向显示。

9. `mvprintw(23, 0, "You chose choice %d with choice string %s\n", choice, choices[choice - 1]);`：在用户做出选择后，打印用户的选择。

10. `endwin();`：退出ncurses模式。

这个程序的主要作用是提供一个文本菜单，用户可以在菜单项之间移动并做出选择。在这个过程中，它使用了ncurses库来创建用户界面，并捕获和处理用户的输入。

# snake.c
这段代码是一个使用ncurses库创建的贪吃蛇游戏。游戏中，玩家通过方向键控制蛇的移动方向，蛇吃到食物后会变长，如果蛇撞到墙壁或者自己的身体，游戏就会结束。

以下是对程序的详细分析：

1. `initNcurse()`：初始化ncurses模式，开启小键盘方向键输入捕捉支持。

2. `initFood()`：在20x20的范围内随机生成食物。

3. `initSnake()`：初始化贪吃蛇，设置默认行走方向为右，创建贪吃蛇的头结点和三个身体结点。

4. `addNode()`：在贪吃蛇的尾部添加一个新的结点。

5. `deleNode()`：删除贪吃蛇的头结点。

6. `hasSnakeNode(int hang,int lie)`：判断地图上当前坐标位置是否存在贪吃蛇身体结点。

7. `hasFood(int hang,int lie)`：判断地图上当前坐标位置是否存在食物。

8. `initMap()`：绘制地图，显示贪吃蛇和食物的位置。

9. `issnakedie()`：判断贪吃蛇是否死亡，如果贪吃蛇撞到墙壁或者自己的身体，就会死亡。

10. `moveSnake()`：移动贪吃蛇，在尾部添加结点，如果有食物则不删除头结点。

11. `refreshjiemian()`：刷新界面，不断的移动贪吃蛇和刷新地图。

12. `turn(int direction)`：改变贪吃蛇的行走方向。

13. `changeDir()`：不断从键盘获取方向键的命令，改变贪吃蛇的行走方向。

14. 在`main()`函数中，使用`pthread_create()`创建两个线程，一个线程用于刷新界面，另一个线程用于获取方向键的命令。

这个程序的主要作用是提供一个贪吃蛇游戏，用户可以通过方向键控制贪吃蛇的移动方向，游戏的目标是让贪吃蛇吃到尽可能多的食物。在这个过程中，它使用了ncurses库来创建用户界面，并捕获和处理用户的输入。
# 退出终端运行程序
在你的程序中，没有提供一个明确的退出机制。然而，你可以使用以下几种方法来退出程序：

1. 在你的程序运行的终端中，按下 `Ctrl+C`。这将发送一个SIGINT信号给你的程序，导致它退出。

2. 如果你的程序在后台运行，你可以先使用 `ps` 命令找到程序的进程ID，然后使用 `kill` 命令来结束它。例如：

```bash
ps aux | grep your_program_name
kill -9 your_program_pid
```

3. 你也可以在你的程序中添加一个退出机制。例如，你可以检测某个特定的键盘输入（比如 'q' 键），当这个输入被检测到时，结束程序。你可以使用 ncurses 库的 `getch()` 函数来获取键盘输入，然后在 `changeDir()` 函数中添加一个检测退出键的逻辑。
# 理解LSB、MSB和大小端模式及网络字节序
LSB（Least Significant Bit）和MSB（Most Significant Bit）是位的概念。在一个字节中，LSB是最低有效位，也就是最右边的位，而MSB是最高有效位，也就是最左边的位。

大小端模式是指存储多字节数据（如int，float，double等）的顺序问题。大端模式（Big-Endian）是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这是人类读写数值的方法。小端模式（Little-Endian）是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这是一种对人类逻辑的颠覆。

网络字节序是一种数据表示格式，它用于在网络中传输数据。由于不同的机器可能使用不同的字节序，所以在进行网络通信时需要将它们统一到网络字节序，这样才能保证数据在不同机器之间正确传输。网络字节序采用的是大端模式。

例如，一个32位的整数0x12345678，在大端模式下存储为：

```
低地址 ----------------> 高地址
0x12 | 0x34 | 0x56 | 0x78
```

在小端模式下存储为：

```
低地址 ----------------> 高地址
0x78 | 0x56 | 0x34 | 0x12
```
>在编程中，`0x`前缀用于表示一个数是十六进制（hexadecimal）的。十六进制是一种基数为16的数制，它的数字包括0-9和A-F。其中，A-F代表了10-15。
例如，`0x12`表示的是十六进制的12，转换为十进制就是18。同样，`0x34`表示的是十六进制的34，转换为十进制就是52。以此类推，`0x56`转换为十进制是86，`0x78`转换为十进制是120。所以，`0x12 | 0x34 | 0x56 | 0x78`这个表达式表示的是四个十六进制数：12、34、56和78。
在网络传输时，无论主机是大端还是小端，都需要将其转换为网络字节序，即大端模式。
# test-end.c
这段C语言代码主要用于展示大小端模式的概念。它首先定义了两个整数变量`value1`和`value2`，然后通过指针`ptr`逐字节打印这两个变量在内存中的存储情况。

以下是对程序的详细分析：

1. `char str[]="hello, 1234";`：定义一个字符串数组`str`，并初始化为"hello, 1234"。

2. `int  value1=0x1234;`：定义一个整数变量`value1`，并初始化为十六进制数0x1234。

3. `int  value2=-3;`：定义一个整数变量`value2`，并初始化为-3。

4. `char *ptr;`：定义一个字符指针`ptr`。

5. `sizeofint=sizeof(int);`：获取int类型的大小，并赋值给变量`sizeofint`。

6. `printf("str=%s \n",str);`：打印字符串`str`。

7. `printf("value1 hex:%0x  dec:%d\n",value1,value1);`：以十六进制和十进制的形式打印`value1`的值。

8. `ptr=(char *) &value1;`：将`value1`的地址赋值给`ptr`。

9. `for(j=0;j<sizeofint;j++) {...}`：循环遍历`value1`的每一个字节，打印其地址和值。

10. `printf("value2 hex:%0x  dec:%d\n",value2,value2);`：以十六进制和十进制的形式打印`value2`的值。

11. `ptr=(char *) &value2;`：将`value2`的地址赋值给`ptr`。

12. `for(j=0;j<sizeofint;j++) {...}`：循环遍历`value2`的每一个字节，打印其地址和值。

通过运行这段代码，你可以观察到在你的机器上是使用大端模式还是小端模式来存储数据。
这个输出结果显示了你的机器是使用小端模式来存储数据的。

对于`value1`，它的十六进制值是0x1234，按照小端模式存储，低位字节（34）在低地址，高位字节（12）在高地址。这就是为什么你看到地址`0x5557a420701c`的值是34，地址`0x5557a420701d`的值是12。而后面的两个地址`0x5557a420701e`和`0x5557a420701f`的值都是00，这是因为`value1`是一个int类型，占4个字节，而0x1234只需要2个字节就可以表示，所以剩下的两个字节都是0。

对于`value2`，它的十进制值是-3，转换为十六进制是0xfffffffd。在小端模式下，低位字节（FD）在低地址，高位字节（FF）在高地址。这就是为什么你看到地址`0x5557a4207020`的值是FD，而后面的三个地址`0x5557a4207021`、`0x5557a4207022`和`0x5557a4207023`的值都是FF。
>我想网络传输为什么要用大端模式，可能是数据在读取时是按照内存地址由低到高读取，所以便于更快的翻译，符合人类逻辑，应该低地址存高位数据，这样也符合人类阅读顺序，想象一段内存，地址由上到下是低——>高，然后读数据也是1234h，12存在低地址，34存在高地址。
# 关于补码表示
在计算机中，负数通常使用补码形式表示。补码是一种特殊的二进制编码方式，它的优点是可以将加法和减法统一为同一种运算。

对于-3，我们首先将其绝对值3转换为二进制，得到`00000011`。然后对这个二进制数取反，得到`11111100`。最后，将取反后的结果加1，得到`11111101`。这就是-3的补码形式。

将`11111101`转换为十六进制，我们可以将其分为两部分：`1111`和`1101`。`1111`转换为十六进制是`F`，`1101`转换为十六进制是`D`。所以，-3的十六进制补码形式是`FD`。

然而，因为我们在这里处理的是一个int类型的数，它占4个字节，所以我们需要在前面补上足够的`F`，使其总长度达到8位。所以，-3的最终十六进制补码形式是`FFFFFFFD`。
补码是一种用于表示整数的二进制编码方式，它在计算机系统中广泛使用，主要有以下几个原因：

1. **简化运算**：补码可以将加法和减法统一为同一种运算。在补码表示法中，负数的补码就是其绝对值的补码加1，这样就可以直接使用加法运算来完成减法。例如，对于`5 - 3`，我们可以将其转换为`5 + (-3)`，然后直接进行加法运算。

2. **节省存储空间**：在补码表示法中，正数和负数都可以被有效地表示和存储。这避免了需要额外的位来存储符号，从而节省了存储空间。

3. **避免歧义**：在没有补码的情况下，零可以有两种表示方式：+0和-0。这会导致一些问题，例如在比较两个数是否相等时，+0和-0应该被认为是相等的，但在没有补码的情况下，它们的二进制表示是不同的。使用补码可以避免这种问题，因为在补码表示法中，零只有一种表示方式。

因此，补码是一种非常有效的整数表示和运算方式，它在计算机系统中得到了广泛的应用。
> 关于我自己对补码发明的理解，比如5-3的运算可以变成5+9-3-9=5+(9-3)-((10)-1)，但是算完9-3后是6，变成了5+6+1-(10)，接下来怎么运算呢，要是让5+6先算就变成1+1-10，(假设都是一位十进制数，11超位了就舍去，变成1)，这样因为进位的问题导致运算出错，但发现刚好满10进位可以让10-9=1，于是变成5+(9-3)-(10-1)=5+6+1-10=2，这个减10的操作跟进位舍去的操作一样，于是可以理解为5-3变成5+9-3+1(-10)=5+9-3+1=2(这里跟进位舍掉的意思一样，因为我们只有一位存储数，5+7=2了)都用4位二进制表示，0101 -0011=0101+1101(负数求补码)=0010,感觉还是说的不太清楚，就想像我们只有一个一位计数器，5-3可以转化为加法5+(9-3+1)-10,5+9-3+1=2;
# 字符串，浮点数，负数的存储形式
是的，字符串中的每个字符在计算机中都是以其ASCII值存储的。ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是一种字符编码标准，用于电子设备中字符的表示和控制。

例如，字符'a'的ASCII值是97，字符'b'的ASCII值是98，等等。当你在程序中创建一个字符串，例如`char str[] = "ab";`，这个字符串在内存中的存储形式就是这些字符的ASCII值，以及一个结束字符'\0'的ASCII值（0）。所以，这个字符串在内存中的存储形式就是`97 98 0`。

在你的程序中，字符串"hello, 1234"在内存中的存储形式就是这些字符的ASCII值，以及一个结束字符'\0'的ASCII值。例如，字符'h'的ASCII值是104，字符'e'的ASCII值是101，等等。所以，这个字符串在内存中的存储形式就是`104 101 108 108 111 44 32 49 50 51 52 0`。

浮点数在计算机中的存储遵循IEEE 754标准。这个标准定义了浮点数的内存布局和数学行为。在这个标准中，一个浮点数被分为三个部分：符号位（S），指数（E）和尾数（M）。

对于单精度浮点数（float），它占用32位，其中：

- 符号位占用1位
- 指数占用8位
- 尾数占用23位

对于双精度浮点数（double），它占用64位，其中：

- 符号位占用1位
- 指数占用11位
- 尾数占用52位

浮点数的值计算公式为：(-1)^S * 1.M * 2^(E-127)（对于float）或者(-1)^S * 1.M * 2^(E-1023)（对于double）。这里，1.M表示1加上尾数M代表的二进制小数。

例如，假设我们有一个32位的浮点数，它的二进制表示为：

```
0 10000001 10110011001100110011010
```

这个浮点数的符号位S为0，指数E为10000001（即129的二进制表示），尾数M为10110011001100110011010。所以，这个浮点数的值为：(-1)^0 * 1.10110011001100110011010 * 2^(129-127) = 1.7。

需要注意的是，由于浮点数的表示方法有其固有的限制，所以并不是所有的实数都能精确地表示为浮点数。在实际使用中，可能会出现精度损失的问题。

将-1.9转换为IEEE 754标准的浮点数表示需要以下步骤：

1. 符号位（S）：因为-1.9是负数，所以符号位为1。

2. 将1.9转换为二进制：1.9的二进制表示为1.11100110011001100110011（无限循环）。我们取前23位作为尾数。

3. 规格化：将二进制表示左移，使其形式为1.xxxxx，同时记录移动的位数。在这个例子中，不需要移动。

4. 计算指数（E）：指数等于移动的位数加上偏移量。对于单精度浮点数，偏移量是127。在这个例子中，指数等于127。

5. 计算尾数（M）：尾数就是规格化后的二进制小数部分。在这个例子中，尾数为11100110011001100110011。

所以，-1.9的浮点数表示为：

```
S EEEEEEEE MMMMMMMMMMMMMMMMMMMMMMM
1 01111111 11100110011001100110011
```
将19.9转换为IEEE 754标准的浮点数表示需要以下步骤：

1. 符号位（S）：因为19.9是正数，所以符号位为0。

2. 将19.9转换为二进制：19的二进制表示为10011，0.9的二进制表示为0.11100110011001100110011（无限循环）。所以，19.9的二进制表示为10011.11100110011001100110011。

3. 规格化：将二进制表示左移，使其形式为1.xxxxx，同时记录移动的位数。在这个例子中，需要左移4位。

4. 计算指数（E）：指数等于移动的位数加上偏移量。对于单精度浮点数，偏移量是127。在这个例子中，指数等于127 + 4 = 131，即10000011。

5. 计算尾数（M）：尾数就是规格化后的二进制小数部分。在这个例子中，尾数为11100110011001100110011。

所以，19.9的浮点数表示为：

```
S EEEEEEEE MMMMMMMMMMMMMMMMMMMMMMM
0 10000011 11100110011001100110011
```
## 为什么浮点数的指数部分要用偏移量加127
在IEEE 754浮点数标准中，指数部分使用了一种称为偏移二进制（bias-notation）的表示方法。这种方法的主要目的是为了能够表示正负指数，并且使得浮点数的排序和整数的排序一致。

在偏移二进制表示法中，实际的指数值等于存储的指数值减去一个固定的偏移量。对于32位的单精度浮点数，这个偏移量是127；对于64位的双精度浮点数，这个偏移量是1023。

使用偏移量的好处是，我们可以用一个无符号整数来表示指数，同时还能表示负指数。例如，如果我们想表示2^-3，那么在偏移二进制表示法中，指数部分就是-3 + 127 = 124。

另外，使用偏移量还有一个好处是，当浮点数按照二进制表示进行排序时，它们的顺序和它们作为浮点数的顺序是一致的。这是因为，当指数部分增加时，浮点数的值也在增加。

所以，虽然在计算指数部分时需要加上一个偏移量，但这种表示方法实际上简化了浮点数的处理，并且使得浮点数的排序和整数的排序一致。

# fread.c出错
开始用fscanf函数读取二进制文件，导致出错
你的程序试图使用`fscanf`函数从二进制文件中读取数据，这可能会导致问题。`fscanf`函数是用于从文本文件中读取格式化的输入的，而不是二进制文件。

在你的程序中，你使用`fwrite`函数以二进制形式将数据写入文件。然后，你试图使用`fscanf`函数以文本形式读取这些数据。这是不可能的，因为二进制数据和文本数据的表示方式是不同的。

你应该使用`fread`函数来读取二进制文件，就像你使用`fwrite`函数来写入二进制文件一样。`fread`函数可以正确地读取二进制数据，并将其转换为适当的数据类型。

以下是你应该使用的代码：

```c
    fread(str, sizeof(char), 12, file);
    fread(&intVal1, sizeof(int), 1, file);
    fread(&intVal2, sizeof(int), 1, file);
    fread(&floatVal1, sizeof(float), 1, file);
    fread(&floatVal2, sizeof(float), 1, file);
    fread(&floatVal3, sizeof(float), 1, file);
    fread(&floatVal4, sizeof(float), 1, file);
```

这样，你就可以正确地从二进制文件中读取数据了。
`fread`函数在C语言中用于从文件中读取数据。它的原型如下：

```c
size_t fread(void *ptr, size_t size, size_t count, FILE *stream);
```

每个参数的含义如下：

- `void *ptr`：这是一个指向你想要读取数据的内存位置的指针。通常，这将是一个指向你想要存储数据的变量的指针。

- `size_t size`：这是你想要读取的每个数据项的大小（以字节为单位）。例如，如果你想要读取的是整数，那么这个值应该是`sizeof(int)`。

- `size_t count`：这是你想要读取的数据项的数量。例如，如果你想要读取10个整数，那么这个值应该是10。

- `FILE *stream`：这是一个指向你想要读取的文件的指针。这个文件应该已经用`fopen`或类似的函数打开。

`fread`函数会从文件中读取`count`个数据项，每个数据项的大小为`size`字节，并将它们存储在`ptr`指向的内存位置。函数返回实际读取的数据项的数量。如果这个数量小于`count`，那么可能是遇到了文件结束或错误。

比如，字符串 "hello, 1234" 实际上包含11个可见字符。这些字符包括5个字母（"hello"），一个逗号，一个空格，以及四个数字（"1234"）。所以总共是11个字符。

在C语言中，空格也是一个字符，所以在计算字符串长度时需要将其计算在内。然后，加上字符串终止符 '\0'，总共就是12个字符。这就是为什么在你的代码中，你使用 `fread(str, sizeof(char), 12, file);` 来读取12个字符。
## fread和fscanf函数区别
`fread`和`fscanf`都是C语言中用于从文件中读取数据的函数，但它们之间存在一些重要的区别：

1. **数据格式**：`fread`用于读取二进制数据，而`fscanf`用于读取格式化的文本数据。如果你正在处理的数据是以二进制形式存储的，那么应该使用`fread`。如果数据是以文本形式存储的，那么应该使用`fscanf`。

2. **使用方式**：`fread`需要知道每个数据项的大小和数量，而`fscanf`则需要一个格式字符串来确定如何解析数据。例如，`fscanf(file, "%d", &intVal)`会从文件中读取一个整数，而`fread(&intVal, sizeof(int), 1, file)`会读取一个大小为`sizeof(int)`字节的二进制数据。

3. **错误处理**：`fread`和`fscanf`在遇到错误时的行为也不同。`fread`在读取失败时会返回实际读取的数据项的数量，这可能小于请求的数量。`fscanf`在成功时返回成功匹配和赋值的项数，如果没有匹配任何项则返回EOF。

总的来说，`fread`和`fscanf`都是用于从文件中读取数据的有用工具，但它们在处理二进制数据和格式化文本数据时有所不同。你应该根据你的具体需求来选择使用哪一个。
# 了解linux可执行程序（ELF格式文件）的结构
Linux可执行程序通常采用ELF（Executable and Linkable Format）格式。ELF是一种通用的二进制文件格式，不仅用于可执行程序，还用于目标文件、共享库等。

一个ELF文件主要由三部分组成：

1. **ELF头（ELF Header）**：这是文件的开始部分，包含了关于文件的元信息，如文件类型（可执行文件、共享对象等）、机器类型（如x86、ARM等）、程序入口点等。此外，它还包含了指向其他两部分（程序头表和节头表）的指针。

2. **程序头表（Program Header Table）**：这部分描述了系统如何创建一个进程映像。它包含了一系列的段（segment），每个段都有特定的属性和大小。例如，代码段（包含程序指令）、数据段（包含程序数据）、动态链接信息等。

3. **节头表（Section Header Table）**：这部分包含了文件的详细段信息，主要用于链接。每个节（section）都包含了特定类型的信息，如符号表、重定位信息等。注意，这部分在可执行文件中可能不需要，因为在运行时不需要这些信息。

这只是ELF文件结构的简单概述。实际上，ELF是一个非常复杂的格式，包含了许多细节。

# 关于GDB调试
在Linux环境下，你可以使用GDB（GNU调试器）来调试你的C程序。以下是一些基本步骤：

1. 首先，你需要使用`-g`选项来编译你的程序，这将在可执行文件中包含调试信息。例如：

```bash
gcc -g -o gdbtest gdbtest.c
```

2. 然后，你可以使用`gdb`命令启动GDB，并将你的程序作为参数传递给它。例如：

```bash
gdb gdbtest
```

3. 在GDB提示符下，你可以使用`break`命令设置断点。例如，要在`add`函数的开始处设置断点，你可以输入：

```bash
break add
```

4. 使用`run`命令开始执行你的程序。当程序达到断点时，它将停止执行。

```bash
run
```

5. 当程序停止时，你可以使用`next`命令执行下一行代码，或者使用`step`命令进入函数。

6. 你可以使用`print`命令打印变量的值。例如，要打印`sum`的值，你可以输入：

```bash
print sum
```

7. 当你完成调试时，你可以使用`quit`命令退出GDB。

以上就是使用GDB进行基本调试的步骤。GDB有许多其他的功能和命令，你可以查阅GDB的手册来了解更多信息。
## 什么是GDB？
GDB是GNU项目的开源调试器，全名为GNU Debugger。它是一个强大的Unix/Linux下的调试工具，可以用来调试各种编程语言编写的程序，包括C、C++、Java、Python等。

GDB主要提供以下功能：

1. 启动你的程序，可以按照你的自定义的条件进行暂停。
2. 检查程序暂停时发生了什么。
3. 当你看到一个错误时，你可以查看在源代码中的哪个位置和为什么会出现错误。
4. GDB可以让你改变程序执行环境，这样你可以测试、检查并纠正你的程序。

使用GDB，你可以在程序运行时观察内部的情况，这对于理解程序的执行过程和调试程序非常有帮助。

## 如何使用GDB，有哪些常见命令
以下是使用GDB的基本步骤和一些常见命令：

1. 使用`gdb`命令启动GDB，并将可执行文件作为参数传递给它。例如：`gdb executable_file`

2. 在GDB提示符下，可以使用以下命令进行调试：
   - `break`：设置断点。例如：`break function_name`或`break line_number`
   - `run`：开始执行程序。例如：`run`
   - `next`：执行下一行代码。例如：`next`
   - `step`：进入函数并执行下一行代码。例如：`step`
   - `print`：打印变量的值。例如：`print variable_name`
   - `continue`：继续执行程序直到下一个断点或程序结束。例如：`continue`
   - `quit`：退出GDB。例如：`quit`

这些是GDB的一些常见命令，你可以根据需要使用它们来调试你的程序。请注意，GDB还有许多其他命令和功能，你可以查阅GDB的文档或使用`help`命令来获取更多信息。
这是一个GDB命令的总结表：

| 命令 | 简写 | 含义 |
| --- | --- | --- |
| file <file> | - | 装入待调试的可执行文件 |
| run | r | 执行程序(至结束) |
| start | - | 开始调试(至main开始处暂停) |
| step | s | 执行一条程序，若为函数则进入内部执行 |
| next | n | 执行一条程序，不进入函数内部 |
| continue | c | 连续运行 |
| finish | - | 运行到当前函数返回 |
| kill | k | 终止正在调试的程序 |
| list | l | 列出源代码的一部分(10行) |
| print <tmp> | p <tmp> | 打印变量的值 |
| info locals | i locals | 查看当前栈帧的局部变量 |
| backtrace | bt | 查看函数调用栈帧编号 |
| frame <id> | f <id> | 选择栈帧(再看局部变量) |
| display <tmp> | - | 每次自动显示跟踪的变量的值 |
| undisplay <tmp> | - | 取消跟踪 |
| break <num> | b | 设置(调试)断点 |
| delete breakpoints <num> | d breakpoints <num> | 删除断点，不加行号则删除所有 |
| disable breakpoints <num> | - | 屏蔽断点 |
| enable breakpoints <num> | - | 启用断点 |
| info breakpoints | i breakpoints | 显示所有断点 |
| break 9 if sum != 0 | - | 根据条件设置断点(sum不等于0时，第9行设断点) |
| set var sum=0 | - | 修改变量的值(使sum变量的值为0) |
| watch <tmp> | - | 监视一个变量的值 |
| examine <...> | - | 查看内存中的地址 |
| jump <num> | j | 跳转执行 |
| signal <...> | - | 产生信号量 |
| return | - | 强制函数返回 |
| call <fun> | - | 强制调用函数 |
| make <...> | - | 不退出gdb下重新产生可执行文件 |
| shell <...> | - | 不退出gdb下执行shell命令 |
| quit | - | 退出GDB |

这个表格包含了GDB的大部分常用命令，可以作为一个快速参考。

### 断点
在GDB中，`start`命令会在`main`函数的开始处自动设置一个临时断点，并开始执行程序。这就是为什么你看到了一个临时断点在`main`函数的开始处。

如果你不想在`main`函数的开始处设置断点，你可以使用`run`命令来开始执行程序，而不是`start`命令。`run`命令会直接开始执行程序，而不会在`main`函数的开始处设置断点。

如果你想在特定的位置设置断点，你可以使用`break`命令。例如，`break function_name`会在指定的函数的开始处设置一个断点，`break line_number`会在指定的行号处设置一个断点。

断点是在程序的特定位置设置的标记，使得每当程序执行到这个位置时，它会在没有用户干预的情况下暂停执行。这使得开发者可以在这个点检查程序的状态，例如查看变量的值，或者步进到下一行代码。

在GDB中，你可以使用`break`命令来设置断点。例如，`break function_name`会在指定的函数的开始处设置一个断点，`break line_number`会在指定的行号处设置一个断点。当程序执行到断点处时，GDB会暂停程序的执行，然后你可以使用其他GDB命令来检查程序的状态或控制程序的执行。

### 一个使用gdb的例子
当然可以。以下是一个简单的GDB使用示例：

首先，假设你有一个名为`main.c`的C程序，内容如下：

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 4);
    printf("The result is %d\n", result);
    return 0;
}
```

你可以使用以下步骤来使用GDB调试这个程序：

1. 首先，你需要使用`-g`选项来编译你的程序，这会在可执行文件中包含调试信息。在终端中输入以下命令：

```bash
gcc -g main.c -o main
```

2. 然后，你可以使用`gdb`命令来启动GDB，并附加到你的程序上。在终端中输入以下命令：

```bash
gdb main
```

3. 在GDB中，你可以使用`break`命令来设置断点。例如，你可以在`main`函数的开始处设置一个断点：

```gdb
break main
```

4. 使用`run`命令来开始执行你的程序。当程序执行到一个断点时，GDB会暂停程序的执行：

```gdb
run
```

5. 当程序暂停时，你可以使用`next`命令来执行下一行代码，或者使用`step`命令来进入函数并执行下一行代码。你也可以使用`print`命令来打印变量的值：

```gdb
next
print result
```

6. 最后，你可以使用`continue`命令来继续执行程序直到下一个断点或程序结束：

```gdb
continue
```

以上就是一个简单的GDB使用示例。在实际使用中，你可能需要根据你的需要来选择使用哪些GDB命令。
# 进程
## 了解孤儿进程及被#1进程收养。(父进程先于子进程终止时，子进程的父进程处理方式)
在Unix和Linux系统中，当一个父进程在其子进程之前结束时，子进程将成为"孤儿进程"。这些孤儿进程将被init进程（PID为1）收养，init进程将接管这些孤儿进程的父进程责任。

init进程是系统启动时由内核启动的第一个进程，它始终在运行，并且它的PID始终为1。init进程的主要职责之一就是接管并处理孤儿进程。

当一个进程结束时，它的子进程将成为孤儿进程，这些孤儿进程的父进程ID（PPID）将被设置为1，表示它们现在是init进程的子进程。init进程将定期调用`wait()`函数来收集其子进程的退出状态，这样就可以防止这些孤儿进程成为僵尸进程。

所以，当你的父进程在其子进程之前结束时，你不需要担心子进程的处理，因为init进程将会接管这些孤儿进程。
### init进程
init进程是Unix和Linux系统中的第一个进程，由内核在系统启动时创建。它的PID（进程ID）始终为1。init进程在系统中有几个重要的职责：

1. **系统初始化**：在系统启动后，init进程是第一个被执行的进程。它负责初始化系统，包括挂载文件系统、启动系统服务等。

2. **进程收养**：如前所述，init进程负责接管和处理孤儿进程。

3. **系统关机和重启**：当你请求系统关机或重启时，这个请求会被发送给init进程。init进程会负责按照正确的顺序停止正在运行的服务和进程，然后安全地关机或重启系统。

4. **服务管理**：在某些系统中，init进程还负责管理系统服务。例如，在使用Systemd的系统中，init进程（也就是systemd）负责启动、停止、重启和管理系统服务。

5. **维护系统运行级别**：在传统的SysV init系统中，init进程还负责维护系统的运行级别，例如运行级别可以决定是否启动图形用户界面。

以上就是init进程的一些主要职责。具体的职责可能会根据你的系统和你的init系统的不同而有所不同。
## 运行ps  ax  -o  user,group,comm,ppid,pid,stat,tty
你运行的`ps ax -o user,group,comm,ppid,pid,stat,tty`命令显示了系统中所有进程的一些详细信息。这些信息包括：

- `user`：进程的所有者
- `group`：进程的组
- `comm`：进程的命令名
- `ppid`：父进程的ID
- `pid`：进程的ID
- `stat`：进程的状态
- `tty`：进程的终端

从你的输出中，我们可以看到有多个进程正在运行，包括init进程（PID为1），以及一些shell进程（如bash和sh），还有一些其他的进程（如node和git）。

你的输出中也显示了一些你的用户进程，如fork1、fork2和fork3，这些可能是你之前在终端中运行的一些程序。

此外，你的输出中还显示了一些进程的状态，如`S`（睡眠状态），`R`（运行状态）和`+`（在前台进程组中）。

这些信息可以帮助你了解系统中正在运行的进程的情况，包括它们的状态、它们的父进程，以及它们正在执行的命令等。
# 文件权限
## 各种命令
### echo
`echo` 是一个常用的 Linux 命令，用于在终端输出字符串或变量的值。以下是一些常见的用法：

1. 输出字符串：`echo` 后面直接跟上你想要输出的字符串，例如：

```bash
echo "Hello, World!"
```

这将在终端打印出 "Hello, World!"。

2. 输出变量的值：如果你有一个变量，你可以使用 `echo` 来输出它的值。例如：

```bash
name="GitHub Copilot"
echo $name
```

这将在终端打印出 "GitHub Copilot"。

3. 输出命令的结果：你可以使用反引号（` `）或者 $() 来执行一个命令，并输出它的结果。例如：

```bash
echo `date`
```

或者

```bash
echo $(date)
```

这将在终端打印出当前的日期和时间。

4. 输出到文件：你可以使用重定向操作符（> 或 >>）将 `echo` 的输出写入到一个文件中。例如：

```bash
echo "Hello, World!" > hello.txt
```

这将创建一个名为 "hello.txt" 的文件，并写入 "Hello, World!"。如果文件已经存在，`>` 将覆盖原有内容，`>>` 将追加到文件末尾。

5. 输出环境变量：你可以使用 `echo` 来输出环境变量的值。例如：

```bash
echo $HOME
```

这将在终端打印出你的主目录的路径。
## chmod
`chmod` 是一个 Linux 命令，用于改变文件或目录的权限。它的名字来自 "change mode" 的缩写。以下是一些常见的用法：

1. 使用数字来改变权限：你可以使用数字来指定文件或目录的权限。数字 4、2 和 1 分别代表读（r）、写（w）和执行（x）权限。例如：

```bash
chmod 755 filename
```

这将设置 `filename` 的权限为 `rwxr-xr-x`，也就是说，文件的所有者有读、写和执行权限，而属于同一组的其他用户和其他所有用户只有读和执行权限。

2. 使用符号来改变权限：你也可以使用符号 `u`（用户）、`g`（组）、`o`（其他）和 `a`（所有）来指定权限。例如：

```bash
chmod u+x filename
```

这将给 `filename` 的所有者添加执行权限。

3. 改变目录及其内容的权限：你可以使用 `-R` 选项来递归地改变一个目录及其内容的权限。例如：

```bash
chmod -R 755 directoryname
```

这将设置 `directoryname` 及其内部所有文件和子目录的权限为 `rwxr-xr-x`。

注意：在使用 `chmod` 命令时，你需要有足够的权限。如果你不是文件的所有者，你可能需要使用 `sudo` 命令。
在 Linux 系统中，文件或目录的权限可以用三个数字来表示，这三个数字分别代表所有者（user）、组（group）和其他用户（other）的权限。

每个数字是其各自权限的总和，其中读（read）权限为 4，写（write）权限为 2，执行（execute）权限为 1。所以，数字 7（4+2+1）代表读、写和执行权限，数字 5（4+0+1）代表读和执行权限。

因此，`chmod 755 filename` 命令将 `filename` 的权限设置为 `rwxr-xr-x`，也就是说，文件的所有者有读、写和执行权限，而属于同一组的其他用户和其他所有用户只有读和执行权限。

### chmod的数字含义
在 Linux 系统中，`chmod` 命令用于修改文件或目录的权限。这些权限可以用三个数字来表示，这三个数字分别代表所有者（user）、组（group）和其他用户（other）的权限。比如chmod 400 filename 代表所有者能读，组和其他用户没有任何权限

每个数字是由 0-7 的整数表示，它们代表了不同的权限组合：

- 0：没有任何权限
- 1：执行权限
- 2：写权限
- 3：写权限和执行权限（2+1）
- 4：读权限
- 5：读权限和执行权限（4+1）
- 6：读权限和写权限（4+2）
- 7：读权限、写权限和执行权限（4+2+1）

例如，`chmod 755 filename` 命令将 `filename` 的权限设置为 `rwxr-xr-x`：

- 第一个数字 7（4+2+1）代表所有者有读、写和执行权限
- 第二个数字 5（4+1）代表同一组的其他用户有读和执行权限
- 第三个数字 5（4+1）代表其他所有用户有读和执行权限

这种表示方法被称为八进制表示法，因为它使用了 0-7 的八个数字。
## ls
`ls` 是一个常用的 Linux 命令，用于列出目录中的文件和子目录。以下是一些常见的用法：

1. 列出文件：直接使用 `ls` 命令可以列出当前目录中的文件和子目录。

```bash
ls
```

2. 列出详细信息：使用 `-l` 选项可以列出文件和子目录的详细信息，包括权限、所有者、大小和修改时间等。

```bash
ls -l
```

3. 列出所有文件：使用 `-a` 选项可以列出所有文件，包括隐藏文件（以点开头的文件）。

```bash
ls -a
```

4. 列出目录：使用 `-d` 选项可以只列出目录。

```bash
ls -d */
```

5. 按修改时间排序：使用 `-t` 选项可以按文件的修改时间排序，最近修改的文件会被列在最前面。

```bash
ls -lt
```

6. 递归列出文件：使用 `-R` 选项可以递归地列出所有子目录中的文件。

```bash
ls -R
```

7. 列出文件大小：使用 `-h` 选项可以以易读的方式显示文件大小。

```bash
ls -lh
```

你可以组合使用这些选项，例如 `ls -lha` 会以详细的格式列出所有文件，包括隐藏文件，并以易读的方式显示文件大小。
### ls -l的出现字母含义
`ls -l` 命令会以详细的列表格式显示文件和目录信息。输出的第一列是一个由 10 个字符组成的字符串，代表文件或目录的权限。这 10 个字符的含义如下：

- 第一个字符表示文件类型。`-` 表示普通文件，`d` 表示目录，`l` 表示符号链接，`b` 表示块设备，`c` 表示字符设备，`s` 表示套接字，`p` 表示命名管道。

- 接下来的三个字符表示所有者（user）的权限。`r` 表示读权限，`w` 表示写权限，`x` 表示执行权限。如果某个权限被禁止，相应的位置会显示 `-`。

- 然后的三个字符表示组（group）的权限，格式和所有者的权限相同。

- 最后的三个字符表示其他用户（other）的权限，格式同样和所有者的权限相同。

>例如，如果 `ls -l` 命令的输出中，某个文件的权限列显示为 `-rwxr-xr--`，那么这表示这是一个普通文件，所有者有读、写和执行权限，组有读和执行权限，其他用户只有读权限。
#### 运行ls -l filename
运行 `ls -l filename` 命令会显示关于指定文件的详细信息。这些信息包括以下几个部分：

1. 文件类型和权限：这是一串由 10 个字符组成的字符串。第一个字符表示文件类型（例如，`-` 表示普通文件，`d` 表示目录）。接下来的九个字符分为三组，每组三个，分别表示文件所有者、组用户和其他用户的读、写和执行权限。

2. 链接数：这是一个数字，表示硬链接到该文件的数量。

3. 文件所有者：这是文件所有者的用户名。

4. 文件所属组：这是文件所属的用户组名。

5. 文件大小：这是文件的大小，单位是字节。

6. 最后修改时间：这是文件最后被修改的日期和时间。

7. 文件名：这是文件的名称。

例如，你可能会看到类似这样的输出：

```bash
-rw-r--r-- 1 user group 1234 Jan 1 12:34 filename
```

这表示 `filename` 是一个普通文件，大小为 1234 字节，最后修改时间是 1 月 1 日 12:34。文件所有者 `user` 有读和写权限，组用户和其他用户只有读权限。
#### 链接数
在 Unix 和 Unix-like 的操作系统中，链接数是指一个文件或目录的硬链接数量。

硬链接是文件系统中的一个引用，指向文件的物理位置。一个文件可以有多个硬链接，每个硬链接都可以作为访问文件的入口。当你创建一个硬链接时，链接数会增加；当你删除一个硬链接时，链接数会减少。

对于文件，链接数通常是 1，因为文件通常只有一个名字。如果你为文件创建了额外的硬链接，链接数会增加。

对于目录，链接数至少是 2。这是因为每个目录都有两个内置的引用：一个是目录自身的名字，另一个是 `.`（指向目录自身）。此外，目录中的每个子目录都有一个 `..` 引用指向父目录，这也会增加父目录的链接数。

请注意，硬链接和软链接（或符号链接）是不同的。硬链接是对文件的直接引用，而软链接是对文件路径的引用。软链接不会影响链接数。
##### 硬链接和软链接
硬链接和软链接（也称为符号链接）是 Unix 和 Unix-like 操作系统中的两种不同类型的链接，它们之间有一些关键的区别：

- 硬链接：硬链接是文件系统中的一个引用，直接指向文件的物理位置。一个文件可以有多个硬链接，每个硬链接都可以作为访问文件的入口。所有的硬链接都是等价的，因为它们都直接指向同一个文件。删除一个硬链接不会影响到其他的硬链接。但是，硬链接不能跨文件系统，也不能链接到目录。

- 软链接：软链接（或符号链接）是一个特殊的文件，这个文件包含了另一个文件的路径。你可以把软链接想象成一个快捷方式，它指向另一个文件或目录。如果你删除了软链接指向的原始文件，软链接将变得无效。软链接可以跨文件系统，也可以链接到目录。

总的来说，硬链接和软链接的主要区别在于：硬链接是对文件的直接引用，而软链接是对文件路径的引用。
让我们通过一些例子来理解硬链接和软链接。

假设我们有一个文件叫做 `file1`，我们可以为这个文件创建硬链接和软链接。

首先，我们创建一个硬链接 `hardlink`：

```bash
ln file1 hardlink
```

现在，`file1` 和 `hardlink` 都指向同一个文件。你可以通过任何一个名字来访问这个文件。如果你修改 `hardlink`，`file1` 的内容也会改变，反之亦然。如果你删除 `file1`，`hardlink` 仍然可以访问文件的内容，因为 `hardlink` 仍然指向文件的物理位置。
在 Unix 和 Unix-like 的操作系统中，当你删除一个文件时，你实际上是删除了一个指向文件内容的引用，而不是删除了文件的内容。如果文件还有其他的硬链接，那么这些链接仍然可以访问文件的内容。

当你创建一个硬链接时，你实际上是创建了一个新的引用，指向文件的物理位置。因此，即使你删除了原始的文件名（也就是删除了一个引用），只要还有其他的硬链接存在，文件的内容就不会被删除。

只有当一个文件的所有硬链接都被删除后，文件的内容才会被删除。这是因为文件系统跟踪每个文件的链接数，只有当链接数降到 0 时，文件系统才会删除文件的内容。

因此，当你删除 `file1` 后，`hardlink` 仍然可以访问文件的内容，因为 `hardlink` 是文件的一个硬链接，它指向文件的物理位置。
接下来，我们创建一个软链接 `softlink`：

```bash
ln -s file1 softlink
```

`softlink` 是一个特殊的文件，它包含了 `file1` 的路径。你可以通过 `softlink` 来访问 `file1` 的内容。但是，如果你删除 `file1`，`softlink` 将变得无效，因为它指向的路径已经不存在了。

总的来说，硬链接是对文件的直接引用，而软链接是对文件路径的引用。硬链接更像是文件的一个别名，而软链接更像是文件的一个快捷方式。

##### ln命令
是的，`ln` 是 Unix 和 Unix-like 操作系统中的一个命令，用于创建链接。它有两种主要的用法：

1. 创建硬链接：`ln target link_name`。这将创建一个名为 `link_name` 的硬链接，指向 `target` 文件。

2. 创建软链接（或符号链接）：`ln -s target link_name`。这将创建一个名为 `link_name` 的软链接，指向 `target` 文件或目录。

在这两个命令中，`target` 是你想要链接到的文件或目录，`link_name` 是你想要创建的链接的名字。
#### 所有者和组及其他用户
在 Unix 和 Unix-like 的操作系统中，每个文件和目录都有一个所有者和一个所属的组。此外，还有一类用户被称为“其他用户”，这些用户既不是文件的所有者，也不属于文件的组。

- 所有者（Owner）：文件的所有者通常是创建文件的用户。所有者对文件有最高的权限，包括读取文件、写入文件和执行文件（如果文件是可执行的）。

- 组（Group）：每个用户都属于一个或多个组，文件的所属组通常是创建文件的用户所在的组。组内的用户对文件的权限可能会受到限制，具体取决于文件的组权限设置。

- 其他用户（Others）：这些用户既不是文件的所有者，也不属于文件的组。他们对文件的权限通常是最低的，具体取决于文件的其他用户权限设置。

文件的所有者、组和其他用户的权限可以通过 `chmod` 命令进行修改，文件的所有者和组可以通过 `chown` 命令进行修改。
##### 组Group
在 Unix 和 Unix-like 的操作系统中，组（Group）是一种用于管理用户权限的机制。一个组可以包含多个用户，这些用户被称为该组的成员。

组的主要目的是方便地管理一组用户对文件和目录的访问权限。例如，你可能有一个项目，你希望你的团队成员都能访问该项目的文件，但你不希望其他人能访问。你可以创建一个组，将你的团队成员添加到该组，然后将该项目的文件的组设置为该组，并给该组的成员读取和写入的权限。

每个文件和目录都有一个所属的组，文件的组可以通过 `chown` 或 `chgrp` 命令进行修改。文件的组权限决定了该文件所属组的成员对该文件的访问权限。

在 Unix 和 Unix-like 的操作系统中，你可以使用 `groups` 命令查看你所属的组，使用 `groupadd` 命令创建新的组，使用 `usermod` 命令将用户添加到组。
在 Unix 和 Unix-like 的操作系统中，每个文件都有一个所有者和一个所属组。当你创建一个文件时，文件的所有者通常是创建文件的用户，文件的所属组通常是创建文件的用户的主要组。

在你的情况下，`USER2022100821` 可能是创建文件的用户的用户名，也是该用户的主要组的组名。这就是为什么当你使用 `ls -l filename` 查看文件信息时，你看到的用户和组都是 `USER2022100821`。

你可以使用 `chown` 命令更改文件的所有者，使用 `chgrp` 命令更改文件的所属组。例如，`chown newuser filename` 会将文件的所有者更改为 `newuser`，`chgrp newgroup filename` 会将文件的所属组更改为 `newgroup`。
在 Unix 和 Unix-like 的操作系统中，每个用户都有一个主要组（或默认组）。当用户创建一个新的文件或目录时，这些文件或目录的所属组默认就是用户的主要组。

用户的主要组通常在用户创建时被设置，通常是在 `/etc/passwd` 文件中指定的。你可以使用 `id` 命令查看用户的主要组，例如 `id -gn username`。

请注意，用户可以属于多个组，这些组被称为用户的附加组。你可以使用 `groups` 命令查看用户的所有组，例如 `groups username`。

总的来说，用户的主要组是用户创建新文件或目录时默认的所属组，而用户的附加组是用户可以访问的其他组。
###### 到底什么是用户的组
在 Unix 和 Unix-like 的操作系统中，组是一种用于管理用户权限的机制。每个用户都属于至少一个组，这个组被称为用户的主要组。用户也可以属于其他的附加组。

组可以用来控制对文件和目录的访问权限。例如，你可以设置一个文件的权限，使得只有特定组的成员才能读取、写入或执行这个文件。

让我们通过一个例子来理解用户和组：

假设我们有三个用户：`alice`、`bob` 和 `charlie`。我们可以创建一个组 `project`，然后将 `alice` 和 `bob` 添加到这个组中。

现在，我们有一个文件 `report.txt`，我们想让 `project` 组的成员可以读取和写入这个文件，但是我们不想让 `charlie` 访问这个文件。我们可以将 `report.txt` 的所属组设置为 `project`，然后设置文件的权限，使得只有所属组的成员才能读取和写入。

在这个例子中，`alice` 和 `bob` 都可以读取和写入 `report.txt`，因为他们是 `project` 组的成员。但是 `charlie` 不能访问 `report.txt`，因为他不是 `project` 组的成员。

你可以使用 `groupadd` 命令创建新的组，使用 `usermod` 命令将用户添加到组，使用 `chgrp` 命令更改文件的所属组，使用 `chmod` 命令更改文件的权限。
在 Unix 和 Unix-like 的操作系统中，当你创建一个新的用户时，系统通常会自动创建一个同名的组，作为这个用户的主要组。这是一种常见的默认设置，用于简化权限管理。

例如，如果你创建了一个名为 `john` 的用户，系统也会创建一个名为 `john` 的组，然后将 `john` 用户添加到 `john` 组。这就是为什么你的用户名和主要组的名字一样。

你可以使用 `id` 命令查看你的用户名和主要组，例如 `id -un` 会显示你的用户名，`id -gn` 会显示你的主要组。
## chown
`chown` 是 "change owner" 的缩写，直译为 "改变所有者"。这个命令在 Unix 和 Unix-like 的操作系统中，用于改变文件或目录的所有者和/或所属的组。

1. 改变所有者：你可以使用 `chown` 命令 followed by the username and the file or directory name to change the owner. 例如：

```bash
chown username filename
```

这将把 `filename` 的所有者改为 `username`。

2. 改变所有者和组：你可以使用 `chown` 命令 followed by the username, a colon, the group name, and the file or directory name to change both the owner and the group. 例如：

```bash
chown username:groupname filename
```

这将把 `filename` 的所有者改为 `username`，并把组改为 `groupname`。

3. 递归地改变所有者和组：你可以使用 `-R` 选项来递归地改变一个目录及其内容的所有者和组。例如：

```bash
chown -R username:groupname directoryname
```

这将把 `directoryname` 及其内部所有文件和子目录的所有者改为 `username`，并把组改为 `groupname`。
>`-R` 选项在 `chown` 命令中用于递归地改变一个目录及其内容的所有者和组。`R` 是 "recursive" 的缩写，意思是 "递归的"。

>如果你不使用 `-R` 选项，`chown` 命令只会改变指定的单个文件或目录的所有者和组。但如果你使用了 `-R` 选项，`chown` 命令不仅会改变指定的目录的所有者和组，还会改变该目录内部所有文件和子目录的所有者和组。

>至于 `-r` 选项，`chown` 命令并不支持这个选项。在 Unix 和 Unix-like 的操作系统中，命令行选项的大小写是有区别的，`-R` 和 `-r` 是两个不同的选项。如果你尝试使用 `-r` 选项，`chown` 命令会给出一个错误消息，告诉你 `-r` 选项是未知的。
注意：在使用 `chown` 命令时，你需要有足够的权限。如果你不是文件的所有者，你可能需要使用 `sudo` 命令。

>你的命令 `sudo chown $USER hello.txt` 将 `hello.txt` 文件的所有者更改为当前用户。这里的 `$USER` 是一个环境变量，代表当前的用户名。

解析这个命令：

- `sudo`：这是一个命令前缀，它允许你以超级用户（或其他用户）的身份执行命令。在这种情况下，它允许你更改文件的所有者，即使你不是文件的当前所有者。

- `chown`：这是一个命令，用于更改文件或目录的所有者。

- `$USER`：这是一个环境变量，代表当前的用户名。在这个命令中，它被用作 `chown` 命令的参数，表示新的所有者。

- `hello.txt`：这是 `chown` 命令的另一个参数，表示要更改所有者的文件。

所以，这个命令的意思是：“以超级用户的身份，将 `hello.txt` 文件的所有者更改为当前用户”。
在 Unix 和 Unix-like 的操作系统中，`$` 符号用于访问环境变量的值。环境变量是在你的 shell 会话中定义的一种特殊类型的变量，它们可以被 shell 脚本和程序访问。

`$USER` 是一个预定义的环境变量，它的值是当前登录用户的用户名。当你在命令中写 `$USER` 时，shell 会自动将其替换为该环境变量的值。

例如，如果你的用户名是 `john`，那么在你的 shell 会话中，`$USER` 将被替换为 `john`。所以，命令 `chown $USER filename` 实际上会被解释为 `chown john filename`。
### 什么是环境变量
环境变量是在操作系统中定义的，可以被操作系统中运行的进程访问的一种特殊类型的变量。它们通常用于存储系统设置或者程序的配置信息。

环境变量的一个常见用途是存储有关系统环境的信息，比如操作系统的名称、系统的主机名、当前用户的用户名等。程序可以读取这些环境变量，以了解它们正在运行的环境。

另一个常见的用途是存储程序的配置信息。例如，一个程序可能需要连接到数据库，它可以从环境变量中读取数据库的地址、用户名和密码。

在 Unix 和 Unix-like 的操作系统中，你可以使用 `echo $VARIABLE_NAME` 命令来查看环境变量的值，使用 `export VARIABLE_NAME=value` 命令来设置环境变量的值。在 Windows 操作系统中，你可以使用 `echo %VARIABLE_NAME%` 命令来查看环境变量的值，使用 `set VARIABLE_NAME=value` 命令来设置环境变量的值。
你运行 `echo $VARIABLE_NAME` 并没有输出任何内容，这可能是因为环境变量 `VARIABLE_NAME` 尚未被定义。

在 Unix 和 Unix-like 的操作系统中，如果你尝试访问一个未定义的环境变量，shell 通常会返回一个空字符串。因此，`echo $VARIABLE_NAME` 命令没有输出任何内容。

你可以使用 `export` 命令来定义一个新的环境变量。例如，运行 `export VARIABLE_NAME=value` 将定义一个名为 `VARIABLE_NAME` 的环境变量，并将其值设置为 `value`。然后，你可以使用 `echo $VARIABLE_NAME` 来查看这个环境变量的值。

## -R和-r出现在哪些命令里
在 Unix 和 Unix-like 的操作系统中，命令行选项的大小写是有区别的，`-R` 和 `-r` 可能在不同的命令中有不同的含义。以下是一些常见命令中 `-R` 和 `-r` 的用法：

- `chown` 和 `chmod`：在这两个命令中，`-R` 用于递归地改变一个目录及其内容的所有者、组或权限。这两个命令都不支持 `-r` 选项。

- `cp` 和 `rm`：在这两个命令中，`-R` 或 `-r` 都可以用于递归地复制或删除一个目录及其内容。

- `ls`：在这个命令中，`-R` 用于递归地列出一个目录及其子目录的内容。`ls` 命令不支持 `-r` 选项。

- `tar`：在这个命令中，`-r` 用于将文件追加到已存在的归档文件中。`tar` 命令不支持 `-R` 选项。

这只是 `-R` 和 `-r` 在一些常见命令中的用法，不同的命令可能会有不同的选项和用法。你应该查阅每个命令的手册页（可以通过 `man` 命令查看）来了解具体的选项和用法。

## rm
`rm` 命令在 Unix 和 Unix-like 的操作系统中用于删除文件和目录。以下是一些常见的 `rm` 命令的用法：

- 删除文件：你可以使用 `rm` 命令 followed by the name of the file to delete it. 例如：

  ```bash
  rm filename
  ```

- 删除目录：要删除一个目录及其内容，你需要使用 `-r` 或 `-R` 选项，这两个选项都表示递归删除。例如：

  ```bash
  rm -r directoryname
  ```

- 提示确认：如果你想在删除文件或目录之前得到确认，你可以使用 `-i` 选项。例如：

  ```bash
  rm -i filename
  ```

- 强制删除：如果你想无视所有警告并强制删除文件或目录，你可以使用 `-f` 选项。例如：

  ```bash
  rm -f filename
  ```

请注意，`rm` 命令删除的文件和目录是无法恢复的，所以在使用 `rm` 命令时要特别小心。
`rm *` 命令会删除当前目录下的所有文件和子目录。这里的 `*` 是一个通配符，代表任何文件或目录名。

请注意，这个命令只会删除文件，而不会删除子目录及其内容。如果你想删除子目录及其内容，你需要使用 `-r` 或 `-R` 选项，例如 `rm -r *`。

另外，`rm *` 命令是非常危险的，因为它会删除当前目录下的所有文件和子目录，而且这个操作是无法恢复的。在使用这个命令时，你应该非常确定你知道你在做什么，并且已经备份了所有重要的数据。

### 文件，子目录
在操作系统中，文件和目录是两种基本的文件系统对象，它们之间有一些关键的区别：

- 文件（File）：文件是存储在磁盘上的一段信息或数据。它可以包含文本、图像、音频、视频等任何类型的数据。文件是数据存储的基本单位。

- 目录（Directory）：目录是用来组织文件和其他目录的。你可以把目录想象成一个容器，它可以包含文件和其他目录。在某些操作系统中，目录也被称为文件夹。

当我们说“目录及其内容”，我们是指目录本身以及目录中的所有文件和子目录。例如，如果你有一个目录，这个目录中有一些文件和其他目录，那么这个目录及其内容就包括这个目录本身、目录中的所有文件，以及目录中的所有子目录及其内容。
## 关于$
在 Unix 和 Unix-like 的操作系统中，`$` 符号有多种用途，具体取决于上下文：

1. 在命令提示符中，`$` 通常表示你是普通用户。如果你是 root 用户，命令提示符通常会是 `#`。

2. 在 shell 脚本中，`$` 用于访问变量的值。例如，如果你有一个变量 `var`，你可以使用 `$var` 来获取这个变量的值。

3. 在命令行中，`$()` 用于命令替换。命令替换会执行括号中的命令，然后将命令的输出替换到原来的位置。例如，`echo $(date)` 会打印当前的日期和时间。

4. 在正则表达式中，`$` 表示行的结束。

这只是 `$` 符号在 Unix 和 Unix-like 的操作系统中的一些常见用途。`$` 符号的具体含义取决于它的上下文和你正在使用的命令或程序。
### shell脚本和命令行，正则表达式
- Shell脚本：Shell脚本是一种用于自动执行命令的脚本语言，它是由一系列命令按照某种顺序执行的文本文件。Shell脚本通常用于自动化常见任务，例如备份文件、安装程序等。

- 命令行：命令行是一种用户与操作系统交互的界面。用户可以在命令行中输入命令，操作系统会执行这些命令并返回结果。命令行界面通常提供了比图形用户界面更强大和灵活的功能。

- 正则表达式：正则表达式是一种用于匹配字符串的模式。你可以使用正则表达式来查找、替换或验证字符串是否符合某种格式。例如，你可以使用正则表达式来查找所有的电子邮件地址、电话号码，或者验证用户输入的密码是否符合要求。
#### 正则表达式
正则表达式，也称为 regex 或 regexp，是一种强大的文本处理工具。它是一种特殊的字符串，可以帮助你以灵活的方式查找、匹配和替换文本。

正则表达式的主要用途是：

- 搜索：你可以使用正则表达式在文本中搜索特定的模式。例如，你可以搜索所有的电子邮件地址或电话号码。

- 验证：你可以使用正则表达式验证文本是否符合特定的格式。例如，你可以验证用户输入的密码是否包含至少一个数字和一个大写字母。

- 替换：你可以使用正则表达式替换文本中的特定模式。例如，你可以将所有的 "colour" 替换为 "color"。

正则表达式由一系列字符和特殊符号组成，每个符号都有特定的含义。例如，`.` 匹配任何单个字符，`*` 匹配前面的元素零次或多次，`[a-z]` 匹配任何小写字母等。

学习正则表达式可能需要一些时间，但一旦你掌握了它，你会发现它是一个非常强大的工具。
## 
