1.	常规存储器管理方式具有哪两大特征? 它对系统性能有何影响? 

虚拟存储器的特征主要包括：

1. 程序地址空间和物理内存的解耦：程序员不再需要关心物理内存的大小和分布，只需要关注自己的程序地址空间。

2. 按需加载和执行：程序的各部分只有在需要时才被加载到内存中执行，不需要的部分可以被换出到磁盘。

3. 内存保护：每个程序都有自己的虚拟地址空间，不会与其他程序的地址空间冲突，从而实现了内存的保护。

4. 共享和复制：虚拟存储器允许多个进程共享同一段内存，或者复制一段内存到另一个进程。

其中，最本质的特征是程序地址空间和物理内存的解耦。这使得程序员可以像操作一个无限大的内存一样编写程序，而不需要关心物理内存的实际大小和分布。这大大简化了程序的编写，提高了程序的可移植性，并使得内存的利用率得到了极大的提高。

    

3. 虚拟存储器有哪些特征? 其中最本质的特征是什么? 

虚拟存储器的特征主要包括：

1. 按需分页：只有当程序需要使用某个页面时，该页面才会被加载到内存中。这使得程序可以使用比物理内存更大的地址空间。

2. 地址空间隔离：每个进程都有自己的虚拟地址空间，这个地址空间与物理内存和其他进程的地址空间是隔离的。这提供了一种内存保护机制，防止进程之间相互干扰。

3. 页面置换：当物理内存不足以容纳所有需要的页面时，操作系统会选择一些页面将其移出内存，以便为新的页面腾出空间。这种机制使得程序可以使用比物理内存更大的地址空间。

4. 内存共享和复制：虚拟存储器允许多个进程共享同一段内存，或者复制一段内存到另一个进程。

其中，最本质的特征是按需分页和地址空间隔离。这两个特征使得每个进程都有自己的独立地址空间，并且只有当需要时才将数据加载p'p'p'p'p'p'p'p'p'p'p'p'p'p'p'p'p'p'p到内存中。这大大提高了内存的利用率，同时也提高了系统的安全性和稳定性。

5. 实现虚拟存储器需要哪几个关键技术? 

实现虚拟存储器需要以下几个关键技术：

1. 分页（Paging）：将虚拟内存和物理内存都分割为固定大小的块，称为页（Page）。每个页在虚拟内存和物理内存中都有一个唯一的标识，称为页号。

2. 页表（Page Table）：页表是一种数据结构，用于存储虚拟页和物理页之间的映射关系。当程序访问一个虚拟地址时，操作系统会查找页表，找到对应的物理页，然后将虚拟地址转换为物理地址。

3. 页面置换算法（Page Replacement Algorithm）：当物理内存不足以容纳所有需要的页时，操作系统需要选择一些页将其移出内存，以便为新的页腾出空间。页面置换算法决定了哪些页应该被移出内存。

4. 内存保护：通过硬件支持，如内存管理单元（MMU），可以实现每个进程只能访问自己的虚拟地址空间，从而防止进程之间相互干扰。

5. 磁盘调度算法：由于磁盘访问速度远慢于内存，因此磁盘调度算法的选择对系统性能有重要影响。常见的磁盘调度算法有先来先服务（FCFS）、最短寻道时间优先（SSTF）、扫描（SCAN）等。


7. 试比较缺页中断机构与一般的中断，它们之间有何明显的区别? 

缺页中断和一般的中断在处理机制和触发条件上有一些明显的区别：

1. 触发条件：一般的中断是由外部事件（如用户输入、硬件设备的信号等）触发的，而缺页中断是由程序访问一个尚未加载到物理内存的虚拟页时触发的。

2. 处理过程：一般的中断处理通常涉及到处理外部事件，如读取用户输入、处理硬件设备的信号等。而缺页中断的处理过程主要是将所需的虚拟页从磁盘加载到物理内存，并更新页表。

3. 处理时间：一般的中断处理时间相对较短，因为它们通常只涉及到CPU和内存的操作。而缺页中断的处理时间通常较长，因为它需要从磁盘读取数据，而磁盘的访问速度远慢于内存。

4. 对系统性能的影响：一般的中断对系统性能的影响较小，因为它们的处理时间短，且发生频率不高。而缺页中断的发生可能会导致程序的执行速度大大降低，因此需要通过合理的页面置换算法和磁盘调度算法来减少缺页中断的发生。

9. 何谓固定分配局部置换和可变分配全局置换的内存分配策略? 

固定分配局部置换和可变分配全局置换是两种不同的内存分配和页面置换策略：

1. 固定分配局部置换：在这种策略中，每个进程在开始运行时都会被分配一个固定数量的内存帧。当进程需要更多的内存帧时，它必须选择自己已经占用的帧进行置换。这种策略的优点是简单，但缺点是可能会导致内存的浪费，因为有些进程可能不需要它们被分配的所有帧，而其他进程可能需要更多的帧。

2. 可变分配全局置换：在这种策略中，内存帧的分配是动态的，即进程可以根据需要获取更多的帧，或者释放不再需要的帧。当需要进行页面置换时，可以选择所有进程的帧，而不仅仅是当前进程的帧。这种策略的优点是可以更有效地利用内存，但缺点是管理起来更复杂，因为需要跟踪每个帧的状态，并在所有进程之间进行调度。

11. 试说明在请求分页系统中页面的调入过程。
　　
在请求分页系统中，页面的调入过程通常涉及以下步骤：

1. 缺页中断：当程序试图访问一个尚未加载到物理内存的页面时，会触发一个缺页中断。

2. 保存现场：操作系统会保存当前的程序计数器、寄存器和其他状态信息，以便在页面调入后能恢复程序的执行。

3. 查找页面：操作系统会查找需要调入的页面在磁盘上的位置。这通常涉及到查找页表和文件系统的元数据。

4. 选择一个内存帧：如果物理内存中没有空闲的帧，操作系统需要选择一个已经使用的帧进行置换。这通常涉及到一个页面置换算法，如最近最少使用（LRU）或先进先出（FIFO）。

5. 从磁盘读取页面：操作系统会将需要的页面从磁盘读取到选择的内存帧中。

6. 更新页表：操作系统会更新页表，将虚拟页号映射到新的物理帧。

7. 恢复现场并继续执行：操作系统会恢复之前保存的程序状态，并继续执行程序。这次，当程序再次试图访问同一个页面时，就可以在内存中找到它了。

以上就是在请求分页系统中页面的调入过程。

13. 在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为
4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。

在请求分页系统中，FIFO（先进先出）页面置换算法是一种简单的算法，它总是选择最早调入内存的页面进行置换。下面我们来计算在给定的页面走向和物理块数下，所发生的缺页次数和缺页率。

首先，我们需要明确一点，缺页次数是指在访问过程中，需要从磁盘调入内存的页面数量。缺页率是指缺页次数占总访问次数的比例。

1. 当物理块数M=3时：

   页面走向为：4、3、2、1、4、3、5、4、3、2、1、5

   在访问过程中，发生的缺页情况如下：

   - 访问4，缺页，调入内存，内存状态：[4]
   - 访问3，缺页，调入内存，内存状态：[4, 3]
   - 访问2，缺页，调入内存，内存状态：[4, 3, 2]
   - 访问1，缺页，调入内存，按照FIFO，置换4，内存状态：[3, 2, 1]
   - 访问4，缺页，调入内存，按照FIFO，置换3，内存状态：[2, 1, 4]
   - 访问3，缺页，调入内存，按照FIFO，置换2，内存状态：[1, 4, 3]
   - 访问5，缺页，调入内存，按照FIFO，置换1，内存状态：[4, 3, 5]
   - 访问4，不缺页
   - 访问3，不缺页
   - 访问2，缺页，调入内存，按照FIFO，置换4，内存状态：[3, 5, 2]
   - 访问1，缺页，调入内存，按照FIFO，置换3，内存状态：[5, 2, 1]
   - 访问5，不缺页

   所以，当M=3时，缺页次数为9，缺页率为9/12=75%。

2. 当物理块数M=4时：

   页面走向为：4、3、2、1、4、3、5、4、3、2、1、5

   在访问过程中，发生的缺页情况如下：

   - 访问4，缺页，调入内存，内存状态：[4]
   - 访问3，缺页，调入内存，内存状态：[4, 3]
   - 访问2，缺页，调入内存，内存状态：[4, 3, 2]
   - 访问1，缺页，调入内存，内存状态：[4, 3, 2, 1]
   - 访问4，不缺页
   - 访问3，不缺页
   - 访问5，缺页，调入内存，按照FIFO，置换4，内存状态：[3, 2, 1, 5]
   - 访问4，缺页，调入内存，按照FIFO，置换3，内存状态：[2, 1, 5, 4]
   - 访问3，缺页，调入内存，按照FIFO，置换2，内存状态：[1, 5, 4, 3]
   - 访问2，缺页，调入内存，按照FIFO，置换1，内存状态：[5, 4, 3, 2]
   - 访问1，缺页，调入内存，按照FIFO，置换5，内存状态：[4, 3, 2, 1]
   - 访问5，缺页，调入内存，按照FIFO，置换4，内存状态：[3, 2, 1, 5]

   所以，当M=4时，缺页次数为10，缺页率为10/12=83.33%。

通过比较，我们可以看到，虽然物理块数增加了，但是由于FIFO算法的特性，缺页次数和缺页率反而增加了。这就是所谓的Belady现象，也就是在某些情况下，增加物理块数可能会导致缺页次数增加。


15. 试说明改进型Clock置换算法的基本原理。

改进型Clock置换算法（也被称为二次机会算法）是一种页面置换算法，它是对基本的Clock算法的改进。这种算法使用两个标志位：引用位R和修改位M。

基本原理如下：

1. 初始化：当一个页面首次被加载到内存中时，它的R和M位都被设置为0。

2. 页面引用：当一个页面被引用时，它的R位被设置为1。如果该页面被修改，那么它的M位也被设置为1。

3. 页面置换：当需要置换一个页面时，改进型Clock算法会按照以下规则选择一个页面：

   - 如果一个页面的R和M位都是0，那么这个页面会被选择进行置换。
   - 如果一个页面的R位是0但M位是1，那么这个页面会被选择进行置换，但在置换之前，需要将这个页面写回到磁盘。
   - 如果一个页面的R位是1，那么这个页面的R位会被设置为0，然后继续寻找下一个页面。
   - 如果所有的页面的R位都是1，那么这个算法会从头开始，将所有页面的R位设置为0，然后重新开始寻找。

这种算法的优点是它考虑了页面是否被修改的情况，因此可以更好地反映页面的使用情况。但是，它需要维护两个标志位，因此比基本的Clock算法更复杂。

17. 页面缓冲算法的主要特点是什么? 它是如何降低页面换进、换出的频率的? 
　　

页面缓冲算法是一种用于管理内存中页面的策略，其主要特点是在内存和磁盘之间维护一个缓冲区，用于暂存最近被替换出内存的页面。这种策略的主要优点是可以减少页面换进、换出的频率，从而提高系统的性能。

页面缓冲算法是如何降低页面换进、换出的频率的呢？

1. 换出页面的缓存：当一个页面被替换出内存时，它不会立即被写回到磁盘，而是被放入缓冲区。如果这个页面很快又被访问，那么它可以直接从缓冲区中取出，而不需要从磁盘中读取。这样就避免了一次磁盘I/O操作。

2. 延迟写回：当一个页面被修改并需要被替换出内存时，它会被放入缓冲区，但不会立即被写回到磁盘。只有当缓冲区满了或者有其他原因需要释放这个页面时，才会将它写回到磁盘。这样可以减少磁盘I/O操作的次数，因为可能在这个页面被写回磁盘之前，它又被访问并修改了。

通过以上两种方式，页面缓冲算法可以有效地降低页面换进、换出的频率，从而提高系统的性能。

19. 何谓工作集? 它是基于什么原理确定的? 

工作集是一种描述程序在一段时间内所需的页面集合的概念。它是由Peter J. Denning在1968年提出的，用于实现动态页面置换算法。

工作集的定义是基于程序的局部性原理确定的。局部性原理是指在一段时间内，程序可能只会访问一部分的地址空间，这部分地址空间就构成了程序的工作集。具体来说，如果我们定义一个固定的时间窗口，那么在这个时间窗口内，程序所访问的所有页面就构成了这个程序的工作集。

工作集模型的主要目标是尽可能地减少缺页率。如果一个程序的工作集完全在内存中，那么这个程序就不会产生缺页。因此，操作系统会尽可能地保持每个程序的工作集在内存中。当内存空间不足时，操作系统会选择那些不在任何程序工作集中的页面进行置换。


21. 试说明如何利用“L=S”准则来调节缺页率，以避免“抖动”的发生。
　
"L=S"准则是一种用于调节缺页率的方法，以避免"抖动"现象的发生。"抖动"是指当系统的内存资源紧张时，可能会频繁地发生页面置换，导致系统性能下降。

"L=S"准则的含义是：系统为进程分配的内存量（L）应等于该进程的工作集的大小（S）。这个准则是基于以下的理论依据：如果一个进程的全部工作集都在内存中，那么这个进程就不会产生缺页，从而避免了"抖动"的发生。

具体实施"L=S"准则的步骤如下：

1. 监控工作集大小：系统需要定期地监控每个进程的工作集大小。这可以通过记录每个进程在一段时间内所访问的页面来实现。

2. 调整内存分配：如果一个进程的工作集大小大于系统为它分配的内存量，那么系统需要增加对这个进程的内存分配，以避免缺页的发生。如果一个进程的工作集大小小于系统为它分配的内存量，那么系统可以减少对这个进程的内存分配，以释放内存资源给其他进程。

通过这种方式，"L=S"准则可以有效地调节缺页率，避免"抖动"的发生，从而提高系统的性能。

23. 在请求段表机制中，应设置哪些段表项? 


在请求段表机制中，通常需要设置以下几个段表项：

1. 段基址（Base）：这是段在物理内存中的起始地址。

2. 段长度（Limit）：这是段的长度或大小。它用于检查地址是否越界。

3. 存在位（Present）：这个位用于指示该段是否在物理内存中。如果该段在内存中，那么这个位就被设置为1；否则，它被设置为0。

4. 修改位（Dirty）：这个位用于指示该段是否被修改过。如果该段被修改过，那么这个位就被设置为1；否则，它被设置为0。

5. 访问权限（Protection）：这些位用于指示对该段的访问权限，如读、写和执行权限。




25. 请对共享段表中的各项作简要说明。

在共享段表机制中，通常需要设置以下几个段表项：

1. 段基址（Base）：这是段在物理内存中的起始地址。在共享段表中，如果两个或更多的进程共享同一个段，那么这些进程的段表中对应的段基址应该是相同的。

2. 段长度（Limit）：这是段的长度或大小。它用于检查地址是否越界。

3. 存在位（Present）：这个位用于指示该段是否在物理内存中。如果该段在内存中，那么这个位就被设置为1；否则，它被设置为0。

4. 修改位（Dirty）：这个位用于指示该段是否被修改过。如果该段被修改过，那么这个位就被设置为1；否则，它被设置为0。

5. 访问权限（Protection）：这些位用于指示对该段的访问权限，如读、写和执行权限。在共享段表中，如果一个段被多个进程共享，那么这个段的访问权限应该是这些进程的访问权限的并集。

　









