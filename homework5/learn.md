## git 
### 怎么查看当前文件夹是否属于git仓库
你可以在终端中使用 `git status` 命令来检查当前文件夹是否属于一个 Git 仓库。如果当前文件夹是一个 Git 仓库，这个命令会显示关于仓库状态的信息。如果当前文件夹不是一个 Git 仓库，这个命令会显示一个错误消息。

在终端中输入以下命令：

```bash
git status
```

如果你看到类似 "On branch master" 或 "No commits yet" 的消息，那么当前文件夹是一个 Git 仓库。如果你看到 "fatal: not a git repository (or any of the parent directories): .git" 的消息，那么当前文件夹不是一个 Git 仓库。
### 怎么提交修改
`git add .` 是一个 Git 命令，用于将当前目录下的所有更改添加到 Git 的暂存区。这包括新文件、已修改的文件和已删除的文件。这是准备提交更改的第一步。

在执行 `git add .` 命令后，你可以使用 `git commit` 命令来提交这些更改。例如：

```bash
git commit -m "Your commit message"
```

其中，"Your commit message" 是你的提交信息，应该简短地描述你所做的更改。
在你提交了更改之后，你可以使用 `git push` 命令将这些更改同步到你的 GitHub 仓库。这个命令会将你的本地仓库的更改推送到远程仓库。

如果你正在使用的分支是 `master`，你可以使用以下命令将更改推送到 GitHub：

```bash
git push origin master
```

这个命令的意思是将 `master` 分支的更改推送到 `origin`，其中 `origin` 通常是你的 GitHub 仓库的别名。

如果你正在使用的分支不是 `master`，你需要将 `master` 替换为你正在使用的分支的名称。例如，如果你正在使用的分支是 `dev`，你应该使用以下命令：

```bash
git push origin dev
```
### 什么是git分支
Git 分支是 Git 版本控制系统的一个重要特性，它允许你在同一份代码库中并行开发多个功能或修复多个问题。

在 Git 中，"分支" 是指向提交对象的可变引用。每次提交时，Git 都会创建一个新的提交对象并更新当前分支的引用，使其指向这个新的提交对象。这样，每个分支都代表了一个独立的开发历史。

你可以使用 `git branch` 命令来创建、列出、删除或重命名分支。你可以使用 `git checkout` 命令来切换到不同的分支。你可以使用 `git merge` 命令来合并两个分支的更改。

使用分支，你可以在不影响主开发线（通常是 `master` 分支）的情况下开发新功能或修复问题。当新功能开发完成或问题修复完成后，你可以将分支的更改合并回主开发线。
### git两台电脑同时用
如果你在两台电脑上都对同一个 GitHub 仓库进行了更改，并且想要保证这两台电脑上的更改都能同步到 GitHub 仓库，你可以按照以下步骤操作：

1. 在第一台电脑上，将你的更改提交到本地 Git 仓库，然后将这些更改推送到 GitHub。你可以使用以下命令：

```bash
git add .
git commit -m "Your commit message"
git push origin master
```

2. 在第二台电脑上，首先使用 `git pull` 命令将 GitHub 仓库的最新更改拉取到本地。这样，你就可以获取到第一台电脑上的更改。然后，将你在第二台电脑上的更改提交到本地 Git 仓库，并将这些更改推送到 GitHub。你可以使用以下命令：

```bash
git pull origin master
git add .
git commit -m "Your commit message"
git push origin master
```

这样，GitHub 仓库就会包含这两台电脑上的所有更改。

注意，如果两台电脑上的更改有冲突（即修改了同一个文件的同一部分），你需要在执行 `git pull` 命令后解决这些冲突，然后再提交和推送更改。


## markdown插入图片
可以直接复制图片插入markdown文档，但是会把图片复制到与该md文件同一目录，可以先批量把这些图片移动到img文件夹，再查找替换即可


在VS Code中，你可以使用"查找和替换"功能来批量修改文本。在你的情况下，你可以使用这个功能来批量修改图片的路径。

以下是如何使用"查找和替换"功能的步骤：

1. 打开你的Markdown文件。
2. 按`Ctrl+F`（在Mac上是`Command+F`）来打开"查找"框。
3. 在"查找"框中输入你想要替换的文本，例如`![alt text](`。
4. 按`Ctrl+H`（在Mac上是`Command+Option+F`）来打开"替换"框。
5. 在"替换"框中输入你想要替换成的文本，例如`![alt text](img/`。
6. 点击"替换全部"按钮（或按`Ctrl+Alt+Enter`）来替换所有匹配的文本。

请注意，这个方法只能用于替换精确匹配的文本。如果你的图片的文件名或路径有不同，你可能需要手动修改它们。

在VS Code中，你可以使用内置的文件浏览器和多选功能来批量删除文件。以下是步骤：

1. 在VS Code的侧边栏中，点击文件浏览器图标（它看起来像两个重叠的方块）来打开文件浏览器。

2. 导航到包含你想要删除的文件的目录。

3. 点击一个文件来选中它，然后按住`Ctrl`（在Mac上是`Command`）并点击其他文件来选择多个文件。

4. 当你选中所有你想要删除的文件后，右键点击任何一个选中的文件，然后选择"删除"。

这将会删除所有选中的文件。请注意，这个操作是不可逆的，所以在删除文件之前，请确保你不再需要这些文件。

如果你想要批量删除特定类型的文件，例如所有的`.png`文件，你可以在VS Code的搜索框中输入`*.png`，然后在搜索结果中选中所有你想要删除的文件，然后右键点击并选择"删除"。

# 文件类型
## 一、stat获取文件信息

`stat`函数是一个Unix系统调用，用于获取文件的状态信息。它的原型通常在`sys/stat.h`头文件中定义，如下所示：

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *path, struct stat *buf);
```

这个函数接收两个参数：一个是文件路径的字符串，另一个是一个`struct stat`类型的指针，这个结构体将被填充为文件的状态信息。

`struct stat`结构体包含了很多关于文件的信息，包括：

- `st_mode`：文件类型和权限
- `st_ino`：i节点号
- `st_dev`：设备ID
- `st_nlink`：硬链接数
- `st_uid`：所有者的用户ID
- `st_gid`：所有者的组ID
- `st_size`：文件的大小（字节）
- `st_atime`，`st_mtime`，`st_ctime`：文件的访问、修改和状态改变时间

`stat`函数成功时返回0，失败时返回-1，并设置`errno`为错误代码。

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
int main(){
    struct stat statbuf;
    int ret = stat("/home/USER2022100821/work/Linux_homework/homework5/test.asm",&statbuf);
    if(ret==-1){
        perror("stat");
        return -1;
    }
    printf("size:%ld\n",statbuf.st_size);
    return 0;
}
```

这段代码是用来获取指定文件（在这个例子中是`/home/USER2022100821/work/Linux_homework/homework5/test.asm`）的大小的。它使用了`stat`函数来获取文件的状态信息，然后打印出文件的大小。

下面是这段代码的详细解释：

1. 首先，定义了一个`struct stat`类型的变量`statbuf`，用来存储文件的状态信息。

2. 调用`stat`函数，第一个参数是要获取状态信息的文件的路径，第二个参数是`struct stat`类型的指针，指向要存储状态信息的结构体。

3. `stat`函数返回0表示成功，返回-1表示失败。如果`stat`函数失败，使用`perror`函数打印错误信息，并返回-1。

4. 如果`stat`函数成功，打印出文件的大小（`statbuf.st_size`）。

5. 最后，程序返回0，表示成功结束。

## 二、lstat创建软连接
`lstat`是一个Unix系统调用，用于获取文件的状态信息，类似于`stat`函数。但是，如果指定的文件是一个符号链接，`lstat`将返回符号链接本身的信息，而不是它所指向的文件的信息。

`lstat`函数的原型如下：

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int lstat(const char *path, struct stat *buf);
```

这个函数接收两个参数：一个是文件路径的字符串，另一个是一个`struct stat`类型的指针，这个结构体将被填充为文件的状态信息。

`lstat`函数成功时返回0，失败时返回-1，并设置`errno`为错误代码。

如果你想获取符号链接所指向的文件的信息，你应该使用`stat`函数。如果你想获取符号链接本身的信息，你应该使用`lstat`函数。

lstat函数和stat函数有什么区别？

`lstat`函数和`stat`函数都是用于获取文件状态信息的系统调用，但是它们处理符号链接的方式不同。

- `stat`函数：当文件是一个符号链接时，`stat`会返回符号链接所指向的文件的信息，而不是符号链接本身的信息。

- `lstat`函数：当文件是一个符号链接时，`lstat`会返回符号链接本身的信息，而不是符号链接所指向的文件的信息。

所以，如果你想获取符号链接本身的信息，你应该使用`lstat`函数。如果你想获取符号链接所指向的文件的信息，你应该使用`stat`函数。

*****

假设我们有一个符号链接`link`，它指向一个文件`file`。我们可以使用`lstat`和`stat`函数来获取这两个文件的信息。

以下是一个C程序的示例，它使用`lstat`和`stat`函数来获取`link`和`file`的信息。

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    struct stat statbuf;
    struct stat lstatbuf;

    // 使用stat函数获取file的信息
    if (stat("file", &statbuf) == -1) {
        perror("stat");
        return -1;
    }

    // 使用lstat函数获取link的信息
    if (lstat("link", &lstatbuf) == -1) {
        perror("lstat");
        return -1;
    }

    printf("Size of file: %ld\n", statbuf.st_size);
    printf("Size of link: %ld\n", lstatbuf.st_size);

    return 0;
}
```

在这个程序中，我们首先使用`stat`函数获取`file`的信息，然后使用`lstat`函数获取`link`的信息。然后我们打印出`file`和`link`的大小。

注意，`link`的大小通常是它的目标文件名的长度，而不是目标文件的大小。这就是`lstat`和`stat`函数的主要区别。

符号链接（Symbolic Link），也被称为软链接，是一种特殊的文件类型，在Unix和Linux系统中常见。它是一个文件，包含了对另一个文件或目录的引用。

符号链接可以看作是一个指向另一个文件或目录的快捷方式。它包含的是目标文件或目录的路径，而不是文件的实际内容。因此，符号链接可以跨文件系统，可以链接到不存在的文件，也可以链接到目录。

创建符号链接的常用命令是`ln -s`，例如：

```bash
ln -s target_file symlink
```

这将创建一个名为`symlink`的符号链接，指向`target_file`。

使用`ls -l`命令，可以看到符号链接文件的详细信息，包括它指向的目标文件。例如：

```bash
ls -l symlink
```

输出可能如下：

```bash
lrwxrwxrwx 1 user group 12 Jan 1 00:00 symlink -> target_file
```

这表明`symlink`是一个符号链接，指向`target_file`。

## 三、文件权限
在Linux系统中，每个文件和目录都有一组权限。这些权限决定了哪些用户可以读取、写入或执行这个文件，或者进入这个目录。

文件权限分为三组，分别是：

- 文件所有者的权限
- 文件所属组的权限
- 其他用户的权限

每组权限包含三种类型：

- 读（r）：用户可以读取文件的内容，或者列出目录的内容。
- 写（w）：用户可以修改文件的内容，或者在目录中创建和删除文件。
- 执行（x）：用户可以执行文件，或者进入目录。

使用`ls -l`命令，可以看到文件的权限。例如：

```bash
-rwxr-xr-x 1 user group 123 Jan 1 00:00 file
```

这个输出表示：

- `-rwxr-xr-x`是文件的权限。第一个字符是文件类型（`-`表示普通文件，`d`表示目录，`l`表示符号链接）。接下来的三个字符是文件所有者的权限（`rwx`表示可读、可写、可执行）。接下来的三个字符是文件所属组的权限（`r-x`表示可读、可执行）。最后的三个字符是其他用户的权限（`r-x`表示可读、可执行）。
- `1`是文件的硬链接数。
- `user`是文件的所有者。
- `group`是文件的所属组。
- `123`是文件的大小（字节）。
- `Jan 1 00:00`是文件的最后修改时间。
- `file`是文件的名字。

是的，你可以使用`chmod`命令来修改文件或目录的权限。`chmod`命令可以接受数字（也称为八进制）或符号来表示权限。

每个权限可以用一个数字表示：

- 4代表读（r）
- 2代表写（w）
- 1代表执行（x）

这些数字可以相加。例如，如果你想设置一个文件的权限为可读、可写（但不可执行），你可以使用数字6（4+2）。

因为文件权限有三组（所有者、组、其他用户），所以你需要提供三个数字。例如，如果你想设置一个文件的权限为所有者可读写执行，组可读执行，其他用户可执行，你可以使用`chmod`命令如下：

```bash
chmod 754 file
```

这里，7（4+2+1）代表所有者的权限（可读、可写、可执行），5（4+1）代表组的权限（可读、可执行），4代表其他用户的权限（可读）。

注意，只有文件的所有者或超级用户（root）可以修改文件的权限。


****
在Linux系统中，文件权限是以位的形式存储的，每种权限（读、写、执行）都对应一个位。因此，我们可以使用位运算来检查用户是否具有某个权限。

例如，假设我们有一个权限值`chmod 754`，它可以转换为二进制形式`111 101 100`。这里，每个数字代表一组权限（所有者、组、其他用户），每个位代表一种权限（读、写、执行）。

如果我们想检查用户是否具有读权限，我们可以使用按位与运算（&）来比较用户的权限位和读权限位（4，或者二进制的`100`）。

以下是一个C程序的示例，它使用按位与运算来检查用户是否具有读权限：

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    struct stat statbuf;

    // 获取文件的权限
    if (stat("file", &statbuf) == -1) {
        perror("stat");
        return -1;
    }

    // 检查用户是否具有读权限
    if (statbuf.st_mode & S_IRUSR) {
        printf("User has read permission\n");
    } else {
        printf("User does not have read permission\n");
    }

    return 0;
}
```

在这个程序中，我们首先使用`stat`函数获取文件的权限，然后使用按位与运算来检查用户是否具有读权限。如果用户具有读权限，`statbuf.st_mode & S_IRUSR`的结果将不为0，否则结果将为0。


在Linux系统中，文件的权限被存储在一个叫做权限位（Permission Bits）的数据结构中。这个数据结构包含了一组标志位，每个标志位代表一种特定的权限。

权限位包括以下几种：

- 用户权限位（User Permission Bits）：这些位定义了文件所有者对文件的权限。
- 组权限位（Group Permission Bits）：这些位定义了文件所属组的成员对文件的权限。
- 其他权限位（Other Permission Bits）：这些位定义了其他所有用户对文件的权限。

每组权限位都包含三个位，分别代表读（r）、写（w）和执行（x）权限。例如，如果一个文件的用户权限位是110（二进制），那么文件所有者有读和写权限，但没有执行权限。
- 4代表读（r）100
- 2代表写（w）010
- 1代表执行（x）001
在C语言中，你可以使用`stat`函数获取一个文件的权限位，然后使用按位与运算（&）来检查特定的权限位是否被设置。例如，`S_IRUSR`是一个常量，代表用户读权限位。如果`statbuf.st_mode & S_IRUSR`的结果不为0，那么文件所有者具有读权限。

>这个权限位是不是三位二进制数，它的值代表着不同权限?
是的，你的理解是正确的。在Linux系统中，每组权限（用户、组、其他）都由三个权限位表示，每个权限位代表一种特定的权限：读（r）、写（w）和执行（x）。

这三个权限位可以用一个三位的二进制数表示，每个位的值（0或1）表示对应的权限是否被赋予。例如，权限位`110`（二进制）表示有读和写权限（但没有执行权限6=2+4,），因为第一位（读）和第二位（写）是1，第三位（执行）是0。

这三个权限位也可以用一个单独的八进制数或一个单独的十进制数表示。例如，八进制数`6`或十进制数`6`都表示有读和写权限（但没有执行权限），因为`6`（八进制）和`6`（十进制）都等于`110`（二进制）。

## 四、文件类型
![alt text](image.png)
在Linux系统中，有以下几种主要的文件类型：

- 普通文件（Regular file）：这是最常见的文件类型，可以包含任何数据。例如，文本文件、二进制文件、图片、视频等。

- 目录（Directory）：目录是包含其他文件和目录的文件。

- 符号链接（Symbolic link）：符号链接是一个特殊的文件，它是对另一个文件的引用。

- 设备文件（Device file）：设备文件是一种特殊的文件，用于表示系统中的设备。设备文件分为两种：字符设备文件和块设备文件。

- 套接字文件（Socket file）：套接字文件用于进程间通信。

- 管道文件（Pipe file）：管道文件也用于进程间通信，通常用于将一个进程的输出连接到另一个进程的输入。

- FIFO：FIFO是一种特殊类型的命名管道文件，用于进程间通信。

你可以使用`ls -l`命令查看文件的类型。在输出的第一个字符表示文件的类型：`-`表示普通文件，`d`表示目录，`l`表示符号链接，`c`表示字符设备文件，`b`表示块设备文件，`s`表示套接字文件，`p`表示管道文件。

对不起，我之前的解释有误。你是对的。在Linux系统中，文件的类型和权限信息被存储在一个16位的模式字段（mode field）中，这个模式字段是inode数据结构的一部分。

这个16位的模式字段可以被分为四部分：

- 前四位表示文件类型。例如，`1000`表示普通文件，`0100`表示目录，`0010`表示字符设备文件，`0001`表示块设备文件等。
- 接下来的三位表示特殊权限位，包括setuid、setgid和sticky位。
- 最后三组各三位表示文件的所有者（user）、组（group）和其他用户（other）的权限。每组三位中，第一位表示读权限，第二位表示写权限，第三位表示执行权限。

例如，如果一个文件的模式字段是`1000100110101010`，那么这个文件是一个普通文件（`1000`），有setuid和sticky位设置（`100`），所有者有读和写权限（`110`），组有读权限（`100`），其他用户有读和执行权限（`101`）。

你可以使用`stat`命令查看文件的模式字段。例如，`stat -c %a file`会显示文件的权限，`stat -c %F file`会显示文件的类型。

>什么是特殊权限
在Linux系统中，除了基本的读、写、执行权限外，还有一些特殊的权限，包括：

- Setuid（设置用户ID）：如果一个可执行文件设置了setuid位，那么无论谁运行这个文件，文件都会以文件所有者的身份运行。这对于需要高权限的程序（如passwd命令）非常有用。

- Setgid（设置组ID）：如果一个可执行文件设置了setgid位，那么无论谁运行这个文件，文件都会以文件所属组的身份运行。如果setgid位被设置在一个目录上，那么在该目录下创建的任何新文件都会继承该目录的组，而不是创建文件的用户的主组。

- Sticky位：如果一个目录设置了sticky位，那么只有文件的所有者、目录的所有者或root用户才能删除目录下的文件。这对于如/tmp目录非常有用，该目录可以被任何人写入，但只有文件所有者才能删除文件。

你可以使用`chmod`命令来设置这些特殊权限。例如，`chmod u+s file`会设置file的setuid位，`chmod g+s file`会设置file的setgid位，`chmod o+t directory`会设置directory的sticky位。

****
![alt text](image-1.png)
`stat -c %a test`命令的输出`755`表示`test`文件的权限设置。这个数字是一个八进制数，每个数字代表一组权限。

`755`可以分解为`7`（所有者权限）、`5`（组权限）和`5`（其他用户权限）。在八进制中，`7`等于二进制的`111`，表示所有者有读（4）、写（2）和执行（1）权限。`5`等于二进制的`101`，表示组和其他用户有读（4）和执行（1）权限，但没有写（2）权限。

所以，`755`的权限设置表示所有者有读、写和执行权限，而组和其他用户只有读和执行权限。



在Linux系统中，`stat`命令默认只显示文件权限的部分信息，即所有者、组和其他用户的读、写、执行权限。这是因为在日常使用中，我们最常关心的就是这些基本权限。

如果你想查看文件的完整权限信息，包括文件类型、特殊权限位等，你可以使用`stat -c %f 文件名`命令。这个命令会显示文件的完整模式字段，以十六进制的形式。

例如，如果`stat -c %f 文件名`命令的输出是`81a4`，那么你可以将这个十六进制数转换为二进制数，得到`1000000110100100`。这个二进制数的前四位`1000`表示文件是一个普通文件，接下来的三位`000`表示没有设置特殊权限位，最后的九位`011010010`表示所有者有读和执行权限，组有读权限，其他用户有读和执行权限。

请注意，`stat -c %f 文件名`命令显示的权限信息可能包含了一些额外的标志位，这些标志位在`stat -c %a 文件名`命令的输出中是看不到的。

`stat -c %f test`命令的输出`81ed`是一个十六进制数，表示文件`test`的完整权限信息。

我们可以将这个十六进制数`81ed`转换为二进制数，得到`1000000111101101`。

这个二进制数的前四位`1000`表示文件是一个普通文件，接下来的三位`000`表示没有设置特殊权限位，最后的九位`111101101`表示所有者有读、写和执行权限（`111`），组有读和执行权限（`101`），其他用户有读和执行权限（`101`）。

所以，`81ed`的权限设置表示文件`test`是一个普通文件，所有者有读、写和执行权限，而组和其他用户只有读和执行权限。
## 题目1
![alt text](image-2.png)
这是你在终端中运行`lstat.c`程序的输出。你使用`gcc`命令编译了`lstat.c`文件，然后运行了生成的可执行文件`a.out`，并给它传递了不同的文件路径参数。

- `./a.out  ..`：这个命令检查了当前目录的父目录`..`。输出`ret:0, .. : directory`表示`lstat`函数成功执行（返回值为0），并且`..`是一个目录。

- `./a.out lstat.c`：这个命令检查了`lstat.c`文件。输出`ret:0, lstat.c : regular`表示`lstat`函数成功执行（返回值为0），并且`lstat.c`是一个普通文件。

- `./a.out /dev/stdin`：这个命令检查了`/dev/stdin`文件。输出`ret:0, /dev/stdin : link`表示`lstat`函数成功执行（返回值为0），并且`/dev/stdin`是一个符号链接。在Linux系统中，`/dev/stdin`通常是一个指向当前进程的标准输入的符号链接。

# 进程
## 如何将程序变为进程。(exec 将程序上的代码及数据替换当前调用exec的进程)
是的，你的理解是正确的。`execve`是Linux系统中所有执行程序函数最底层的实现。它会替换当前进程的映像为新的程序文件，新的程序从其`main`函数开始执行。

`execve`函数的参数如下：

- `__path`：这是要执行的程序文件的完整路径。这个路径必须是绝对路径，`execve`函数不会在`PATH`环境变量指定的目录中查找程序文件。

- `__argv`：这是一个字符串数组，表示要传递给新程序的命令行参数。这个数组的第一个元素应该是程序的名称，最后一个元素必须是`NULL`。

- `__envp`：这是一个字符串数组，表示要设置的环境变量。每个字符串的格式为`name=value`，最后一个元素必须是`NULL`。

如果`execve`函数成功执行，它不会返回。如果函数返回，那么一定是发生了错误，错误码会保存在`errno`变量中。

以下是一个使用`execve`函数的简单示例。这个程序会执行`/bin/ls`命令，显示当前目录的内容。

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *path = "/bin/ls";  // 要执行的程序的路径
    char *argv[] = { "ls", NULL };  // 命令行参数，第一个参数是程序的名称
    char *envp[] = { NULL };  // 环境变量，这里没有设置任何环境变量

    if (execve(path, argv, envp) == -1) {
        perror("execve");  // 如果execve函数返回，打印错误信息
    }

    return 0;
}
```



这个程序首先定义了要执行的程序的路径、命令行参数和环境变量。然后，它调用`execve`函数执行程序。如果`execve`函数返回，那么一定是发生了错误，程序会使用`perror`函数打印错误信息。

注意，`execve`函数会替换当前进程的映像，所以如果`execve`函数成功执行，`main`函数中`execve`函数后面的代码将不会被执行。

这个程序是一个简单的`execve`函数的使用示例。它接受一个命令行参数，该参数是要执行的程序的路径，然后使用`execve`函数执行该程序。

以下是带有注释的代码：

```c
#include <stdio.h>
#include <unistd.h>

extern char **__environ;  // 声明外部变量__environ，它是一个指向所有环境变量的指针

int main(int argc, char **argv)
{
    // 检查是否提供了要执行的程序的路径
    if (argc < 2)
    {
        fprintf(stderr, "Usage:%s <file to exec>\n", argv[0]);
        return -1;
    }

    char *cmdline[] = {"sh", NULL};  // 命令行参数，第一个参数是程序的名称

    // 调用execve函数执行程序，使用__environ作为环境变量
    execve(argv[1], cmdline, __environ);

    // 如果execve函数返回，打印错误信息
    perror("execve:");

    return 0;
}
```

这个程序首先检查是否提供了要执行的程序的路径。如果没有，它会打印使用说明并退出。然后，它调用`execve`函数执行程序，使用`__environ`作为环境变量。如果`execve`函数返回，那么一定是发生了错误，程序会使用`perror`函数打印错误信息。

编译后运行./a.out /usr/bin/gedit
你的程序将尝试使用`execve`函数执行`/usr/bin/gedit`。这将启动gedit编辑器。`execve`函数将替换当前进程的映像为gedit程序，所以如果`execve`函数成功执行，`main`函数中`execve`函数后面的代码将不会被执行。

如果`execve`函数执行失败（例如，`/usr/bin/gedit`不存在或者没有执行权限），那么`execve`函数会返回，并且`perror`函数会打印错误信息。

注意，你的程序将`sh`作为程序的名称传递给`execve`函数，这可能会导致一些问题，因为gedit可能会期望其程序名称是`gedit`。如果你想要正确地执行gedit，你应该将`cmdline`数组的第一个元素改为`gedit`。

## 题目2
这个程序主要用于测试`execve`函数的行为。它首先注册了一个信号处理函数，然后暂停等待信号。收到信号后，它会调用`execve`函数执行另一个程序。

以下是带有注释的代码：

```c
#include <stdio.h>
#include <unistd.h>
#include<signal.h>

void handler(int n)   // 自定义的信号处理函数，用于接收SIGUSR1信号
{
    printf("get signal  USR1， test exec continue \n");
}

int main(int argc,char *argv[])
{
    char *env_execve[]={"ONE=1","TWO=2", NULL};  // 要设置的环境变量
    char *argv_execve[]={"first","second", NULL};  // 要传递给新程序的命令行参数

    if (argc<2) {   // 检查是否提供了要执行的程序的路径
        printf("usage: testexec  prg \n");
        return(1);
    }

    signal(SIGUSR1,handler); // 注册SIGUSR1信号的处理函数

    printf("before exec,  pid:%d, ppid:%d, euid:%d\n", getpid(), getppid(), geteuid());  // 打印当前进程的信息

    pause();  // 暂停进程，等待信号

    // 调用execve函数执行程序
    if(execve(argv[1], argv_execve, env_execve)<0)
         perror("Err on execve");  // 如果execve函数返回，打印错误信息

    printf("after exec, pid:%d, ppid:%d, euid:%d\n", getpid(), getppid(), geteuid());  // 打印当前进程的信息

    return(0);
}
```

这个程序首先定义了要设置的环境变量和要传递给新程序的命令行参数。然后，它检查是否提供了要执行的程序的路径。如果没有，它会打印使用说明并退出。然后，它注册了SIGUSR1信号的处理函数，并打印当前进程的信息。接着，它暂停进程，等待信号。收到信号后，它会调用`execve`函数执行程序。如果`execve

