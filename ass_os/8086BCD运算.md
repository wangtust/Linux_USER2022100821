# 加减乘除
8086 微处理器提供了一系列的算术指令来执行加法、减法、乘法和除法操作。以下是一些主要的算术指令：

1. **加法指令**：
   - `ADD`：将两个操作数相加，并将结果存储在第一个操作数中。
   - `ADC`：带进位的加法操作。

2. **减法指令**：
   - `SUB`：从第一个操作数中减去第二个操作数，并将结果存储在第一个操作数中。
   - `SBB`：带借位的减法操作。

3. **乘法指令**：
   - `MUL`：无符号乘法。将源操作数与 AX 寄存器的内容相乘，结果存储在 AX（如果源操作数是 8 位）或 DX:AX（如果源操作数是 16 位）。
   - `IMUL`：有符号乘法。操作方式与 `MUL` 相同，但处理的是有符号数。

4. **除法指令**：
   - `DIV`：无符号除法。将 AX（如果源操作数是 8 位）或 DX:AX（如果源操作数是 16 位）除以源操作数，商存储在 AX 或 AL，余数存储在 DX 或 AH。
   - `IDIV`：有符号除法。操作方式与 `DIV` 相同，但处理的是有符号数。

请注意，这些指令都会影响标志寄存器的状态。例如，如果结果为零，零标志（ZF）会被设置；如果结果为负，符号标志（SF）会被设置；如果发生溢出，溢出标志（OF）会被设置。
# BCD码
BCD（Binary Coded Decimal）码是一种二进制编码方法，用于表示十进制数字。每个十进制数字都被表示为一个四位的二进制数。例如，十进制数字 9 在 BCD 中被表示为 1001。

BCD 码有两种形式：压缩（Packed）和非压缩（Unpacked）。

1. **非压缩 BCD 码**：在非压缩 BCD 码中，每个十进制数字被存储在一个字节中。高四位通常为 0，低四位存储 BCD 码。例如，数字 9 在非压缩 BCD 中被表示为 0000 1001。

2. **压缩 BCD 码**：在压缩 BCD 码中，一个字节中可以存储两个十进制数字。高四位存储一个 BCD 码，低四位存储另一个 BCD 码。例如，数字 19 在压缩 BCD 中被表示为 0001 1001。

压缩 BCD 码比非压缩 BCD 码更节省存储空间，但处理起来稍微复杂一些。
# 十进制用BCD码运算
## 压缩BCD
`DAA`（Decimal Adjust after Addition）和 `DAS`（Decimal Adjust after Subtraction）是 8086 微处理器中的两个指令，用于在二进制加法和减法操作后调整 BCD（Binary Coded Decimal）结果。

1. **DAA 指令**：`DAA` 指令用于在执行二进制加法操作后调整结果，使其成为有效的 BCD 数字。如果 AL 寄存器的低四位大于 9，或者辅助进位标志（AF）被设置，`DAA` 指令会给 AL 寄存器的低四位加 6。如果 AL 寄存器的高四位大于 9，或者进位标志（CF）被设置，`DAA` 指令会给 AL 寄存器的高四位加 6。

2. **DAS 指令**：`DAS` 指令用于在执行二进制减法操作后调整结果，使其成为有效的 BCD 数字。如果 AL 寄存器的低四位大于 9，或者辅助进位标志（AF）被设置，`DAS` 指令会从 AL 寄存器的低四位减 6。如果 AL 寄存器的高四位大于 9，或者进位标志（CF）被设置，`DAS` 指令会从 AL 寄存器的高四位减 6。

这两个指令都会影响进位标志（CF）和辅助进位标志（AF）。`DAA` 和 `DAS` 指令在处理包含 BCD 数字的算术操作时非常有用。

`DAA` 和 `DAS` 指令的目的是在二进制加法或减法操作后，将结果调整为有效的 BCD（二进制编码的十进制）数字。BCD 编码的特点是每个十进制数字用四位二进制数表示，因此每个数字的范围是 0-9。如果在加法或减法操作后，某个四位二进制数的值超过了 9，就需要进行调整。

让我们通过一个例子来看看这是如何工作的：

假设我们要执行以下的 BCD 加法操作：

```
BCD:    8    7
Binary: 1000 0111
+
BCD:    6    5
Binary: 0110 0101
-----------------
Binary: 1110 1100
```

二进制加法的结果是 `1110 1100`，转换为十进制是 236，但我们实际上想要的结果是 87 + 65 = 152。这是因为我们是在对每个四位二进制数（即每个 BCD 数字）分别进行加法操作，而不是对整个八位二进制数进行加法操作。

这时，我们就需要使用 `DAA` 指令来调整结果。`DAA` 指令会检查 AL 寄存器的低四位和高四位，如果任何一部分大于 9，就会加 6（因为 16（二进制的基数） - 10（十进制的基数） = 6）。

在这个例子中，低四位是 1100（十进制的 12），高四位是 1110（十进制的 14），所以两部分都需要加 6：

```
Binary: 1110 1100
DAA
Binary: 0001 0100 0010
BCD:    1    5    2
```

现在，结果是 `0001 0100 0010`，转换为十进制是 152，这就是我们想要的结果。

`DAS` 指令的工作方式类似，但用于减法操作，并且是减去 6 而不是加 6。
## 非压缩BCD
`AAA`（ASCII Adjust after Addition）和 `AAS`（ASCII Adjust after Subtraction）是 8086 微处理器中的两个指令，用于在二进制加法和减法操作后调整 ASCII 码的结果。

1. **AAA 指令**：`AAA` 指令用于在执行二进制加法操作后调整结果，使其成为有效的 ASCII 码。如果 AL 寄存器的低四位大于 9，或者辅助进位标志（AF）被设置，`AAA` 指令会给 AL 寄存器的低四位加 6，并给 AH 寄存器加 1。

2. **AAS 指令**：`AAS` 指令用于在执行二进制减法操作后调整结果，使其成为有效的 ASCII 码。如果 AL 寄存器的低四位大于 9，或者辅助进位标志（AF）被设置，`AAS` 指令会从 AL 寄存器的低四位减 6，并从 AH 寄存器减 1。

这两个指令都会影响进位标志（CF）和辅助进位标志（AF）。`AAA` 和 `AAS` 指令在处理包含 ASCII 码的算术操作时非常有用。

好的，让我们通过一个例子来看看 `AAA` 和 `AAS` 指令是如何工作的：

假设我们要执行以下的 ASCII 加法操作：

```
ASCII:    3    7
Binary: 0011 0111
+
ASCII:    4    6
Binary: 0100 0110
-----------------
Binary: 0111 1101
```

二进制加法的结果是 `0111 1101`，转换为十进制是 125，但我们实际上想要的结果是 37 + 46 = 83。这是因为我们是在对每个四位二进制数（即每个 ASCII 数字）分别进行加法操作，而不是对整个八位二进制数进行加法操作。

这时，我们就需要使用 `AAA` 指令来调整结果。`AAA` 指令会检查 AL 寄存器的低四位，如果大于 9，就会加 6，并给 AH 寄存器加 1。

在这个例子中，低四位是 1101（十进制的 13），所以需要加 6：

```
Binary: 0111 1101
AAA
Binary: 0000 1000 0011
ASCII:    8    3
```

现在，结果是 `0000 1000 0011`，转换为十进制是 83，这就是我们想要的结果。

`AAS` 指令的工作方式类似，但用于减法操作，并且是减去 6 而不是加 6。例如，如果我们有两个 ASCII 数字 46 和 37，我们想要执行减法操作 46 - 37，那么 `AAS` 指令就可以用来调整结果，使其成为有效的 ASCII 数字。
## 非压缩的BCD乘法
`AAM`（ASCII Adjust after Multiplication）是 8086 微处理器中的一个指令，用于在二进制乘法操作后调整 ASCII 码的结果。

`AAM` 指令将 AL 寄存器中的二进制数转换为两个 BCD（二进制编码的十进制）数字。高位 BCD 数字存储在 AH 寄存器中，低位 BCD 数字保留在 AL 寄存器中。

例如，如果 AL 寄存器中的值是 27（十进制），执行 `AAM` 指令后，AH 寄存器中的值将是 2，AL 寄存器中的值将是 7。这是因为 27 可以被表示为两个 BCD 数字 2 和 7。

`AAM` 指令在处理包含 ASCII 码的乘法操作时非常有用。

当然可以。让我们通过一个例子来看看 `AAM` 指令是如何工作的：

假设我们要执行以下的 ASCII 乘法操作：

```
ASCII:    5    6
Binary: 0101 0110
*
ASCII:    2
Binary: 0010
-----------------
Binary: 1011 0000
```

二进制乘法的结果是 `1011 0000`，转换为十进制是 176，但我们实际上想要的结果是 56 * 2 = 112。这是因为我们是在对每个四位二进制数（即每个 ASCII 数字）分别进行乘法操作，而不是对整个八位二进制数进行乘法操作。

这时，我们就需要使用 `AAM` 指令来调整结果。`AAM` 指令会将 AL 寄存器中的二进制数转换为两个 BCD（二进制编码的十进制）数字。高位 BCD 数字存储在 AH 寄存器中，低位 BCD 数字保留在 AL 寄存器中。

在这个例子中，AL 寄存器中的值是 176，执行 `AAM` 指令后，AH 寄存器中的值将是 11，AL 寄存器中的值将是 2：

```
Binary: 1011 0000
AAM
Binary: 0000 1011 0010
ASCII:    1    1    2
```

现在，结果是 `0000 1011 0010`，转换为十进制是 112，这就是我们想要的结果。

`AAD`（ASCII Adjust before Division）是 8086 微处理器中的一个指令，用于在二进制除法操作前调整 ASCII 码的操作数。

`AAD` 指令将 AH 寄存器中的 BCD（二进制编码的十进制）数字和 AL 寄存器中的 BCD 数字合并为一个二进制数，存储在 AL 寄存器中。AH 寄存器被清零。

例如，如果 AH 寄存器中的值是 4，AL 寄存器中的值是 7（表示 BCD 数字 47），执行 `AAD` 指令后，AH 寄存器中的值将是 0，AL 寄存器中的值将是 47（十进制）。这是因为 47 可以被表示为一个二进制数 47。

`AAD` 指令在处理包含 ASCII 码的除法操作时非常有用。

当然可以。让我们通过一个例子来看看 `AAD` 指令是如何工作的：

假设我们要执行以下的 ASCII 除法操作：

```
ASCII:    9    6
Binary: 1001 0110
/
ASCII:    2
Binary: 0010
```

在这个例子中，我们实际上想要的结果是 96 / 2 = 48。但是，如果我们直接对整个八位二进制数进行除法操作，结果可能会不正确。

这时，我们就需要使用 `AAD` 指令来调整操作数。`AAD` 指令将 AH 寄存器中的 BCD（二进制编码的十进制）数字和 AL 寄存器中的 BCD 数字合并为一个二进制数，存储在 AL 寄存器中。AH 寄存器被清零。

在这个例子中，AH 寄存器中的值是 9，AL 寄存器中的值是 6，执行 `AAD` 指令后，AH 寄存器中的值将是 0，AL 寄存器中的值将是 96（十进制）：

```
Binary: 1001 0110
AAD
Binary: 0000 0110 0000
ASCII:    0    6    0
```

现在，我们可以对 AL 寄存器中的值（96）进行除法操作，得到正确的结果 48。