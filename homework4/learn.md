# wav文件

```bash
root@Y7000P:/home/USER2022100821/work/Linux_homework/homework4# xxd -l 44 523hz8k8bit.wav
00000000: 5249 4646 641f 0000 5741 5645 666d 7420  RIFFd...WAVEfmt 
00000010: 1000 0000 0100 0100 401f 0000 401f 0000  ........@...@...
00000020: 0100 0800 6461 7461 401f 0000            ....data@...
```
你提供的是一个 WAV 文件头的十六进制表示。这个头信息包含了 WAV 文件的一些基本属性。以下是每个部分的解释：

- `5249 4646`：这是 "RIFF" 的 ASCII 码的十六进制表示，表示这是一个 RIFF 文件格式。
- `641f 0000`：这是文件大小，以字节为单位，不包括前 8 个字节。这个值是小端格式，所以实际的大小是 `0x00001f64`，即 8036 字节。
- `5741 5645`：这是 "WAVE" 的 ASCII 码的十六进制表示，表示这是一个 WAV 文件。
- `666d 7420`：这是 "fmt " 的 ASCII 码的十六进制表示，表示接下来是格式块。
- `1000 0000`：这是格式块的大小，以字节为单位。这个值是小端格式，所以实际的大小是 `0x00000010`，即 16 字节。
- `0100`：这是音频格式，`0x0001` 表示 PCM。
- `0100`：这是声道数，`0x0001` 表示单声道。
- `401f 0000`：这是采样率，以 Hz 为单位。这个值是小端格式，所以实际的采样率是 `0x00001f40`，即 8000 Hz。
- `401f 0000`：这是字节率，以字节/秒为单位。这个值是小端格式，所以实际的字节率是 `0x00001f40`，即 8000 字节/秒。
- `0100`：这是每个样本的字节数，`0x0001` 表示每个样本 1 字节。
- `0800`：这是每个样本的位数，`0x0008` 表示每个样本 8 位。
- `6461 7461`：这是 "data" 的 ASCII 码的十六进制表示，表示接下来是数据块。
- `401f 0000`：这是数据块的大小，以字节为单位。这个值是小端格式，所以实际的大小是 `0x00001f40`，即 8000 字节。

所以，这是一个单声道、采样率 8000 Hz、每个样本 8 位的 PCM WAV 文件，数据块的大小是 8000 字节。

## 为什么参数是44
WAV 文件的头部信息，也被称为 "WAV 文件头" 或 "WAV 文件元数据"，通常是 44 字节长。这 44 字节包含了关于音频数据的重要信息，如采样率、位深度、声道数等。

以下是 WAV 文件头的一般结构：

- RIFF header (12 字节)
- fmt subchunk (24 字节)
- data subchunk header (8 字节)

这些部分加起来总共是 44 字节。这就是为什么我们通常只查看前 44 字节来查看 WAV 文件头的信息。

然而，有些 WAV 文件可能有额外的元数据，这些元数据会在 data subchunk header 之后。如果你想查看这些额外的元数据，你可能需要查看超过 44 字节的数据。

WAV 文件的头部信息是由以下几个部分组成的：

- RIFF header：这是文件的开始，长度为 12 字节。它包含了 "RIFF" 标记（4 字节），整个文件的大小（4 字节），以及 "WAVE" 标记（4 字节）。

- fmt subchunk：这个部分描述了音频数据的格式，长度为 24 字节。它包含了 "fmt " 标记（4 字节），fmt subchunk 的大小（4 字节，通常为 16），音频格式（2 字节，通常为 1 表示 PCM），声道数（2 字节），采样率（4 字节），字节率（4 字节），块对齐（2 字节），以及每个样本的位数（2 字节）。

- data subchunk header：这个部分标记了音频数据的开始，长度为 8 字节。它包含了 "data" 标记（4 字节）和音频数据的大小（4 字节）。

这些部分加起来就是 WAV 文件头的 44 字节。然而，有些 WAV 文件可能有额外的元数据，这些元数据会在 data subchunk header 之后。

"RIFF" 是 "Resource Interchange File Format" 的缩写，这是一种用于存储音频、视频和文本数据的文件格式。在 WAV 文件中，"RIFF" 标记标识了文件是一个 RIFF 文件。

"RIFF" 标记是文件头的前 4 个字节，通常是 ASCII 字符 "R", "I", "F", "F"。这个标记后面跟着的 4 个字节表示整个文件的大小，然后是 "WAVE" 标记，表示这是一个 WAV 文件。

在处理 WAV 文件时，通常首先检查 "RIFF" 标记，以确认文件是一个有效的 RIFF 文件。

"wave" 标记在 WAV 文件的 RIFF 头部中，用来标识这个文件是一个 WAV 格式的音频文件。它紧跟在 "RIFF" 标记和文件大小之后。

"wave" 标记是由 ASCII 字符 "W", "A", "V", "E" 组成的 4 个字节。在读取 WAV 文件时，通常会检查这个标记，以确认文件是一个有效的 WAV 文件。

如果在预期的位置没有找到 "wave" 标记，那么文件可能不是一个有效的 WAV 文件，或者可能被损坏。

"fmt " subchunk 是 WAV 文件头部的一部分，它描述了音频数据的格式。这个部分的长度通常是 24 字节，包含以下信息：

- "fmt " 标记：这是 4 个字节，通常是 ASCII 字符 "f", "m", "t", " "。
- fmt subchunk 的大小：这是 4 个字节，通常是 16，表示 fmt subchunk 的剩余部分的大小。
- 音频格式：这是 2 个字节，通常是 1，表示 PCM（脉冲编码调制）。
- 声道数：这是 2 个字节，表示音频的声道数，例如 1 表示单声道，2 表示立体声。
- 采样率：这是 4 个字节，表示每秒的样本数，例如 44100。
- 字节率：这是 4 个字节，表示每秒的字节数，它等于采样率 * 块对齐。
- 块对齐：这是 2 个字节，表示每个样本的字节数，它等于声道数 * 每个样本的位数 / 8。
- 每个样本的位数：这是 2 个字节，表示每个样本的位数，例如 16。

这些信息对于解码和播放 WAV 文件的音频数据是必要的。
## 终端打开问题
>每次打开终端自动到root用户下

你的问题可能是由于你的 shell 的默认用户设置为了 root。你可以通过修改你的 shell 的配置文件来改变默认用户。

如果你使用的是 bash，那么你可以在你的 home 目录下找到一个名为 `.bashrc` 或 `.bash_profile` 的文件，打开这个文件并在文件的末尾添加以下行：

```bash
su - USER2022100821
```

然后保存并关闭文件。下次你打开一个新的终端时，你应该会自动切换到 USER2022100821 用户。

如果你使用的是其他的 shell，那么你需要找到对应的配置文件并进行类似的修改。例如，如果你使用的是 zsh，那么你需要修改 `.zshrc` 文件。

请注意，这种方法需要你的 USER2022100821 用户有权限切换到其他用户。如果没有，你可能需要在 root 用户下运行 `visudo` 命令，并在打开的文件中添加一行，允许 USER2022100821 用户无需密码就可以切换到其他用户：

```bash
USER2022100821 ALL=(ALL:ALL) NOPASSWD: ALL
```

然后保存并关闭文件。这样，USER2022100821 用户就可以无需密码就可以切换到其他用户了。

>怎么查看当前用户是不是root权限
在 Linux 中，你可以通过运行 `sudo -l` 命令来查看当前用户是否有 root 权限。这个命令会列出当前用户可以以 sudo 方式运行的所有命令。如果输出中包含 `(ALL : ALL) ALL`，那么当前用户就有 root 权限。

以下是运行 `sudo -l` 命令的示例：

```bash
$ sudo -l
Matching Defaults entries for username on this host:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User username may run the following commands on this host:
    (ALL : ALL) ALL
```

在这个示例中，username 用户可以以 sudo 方式运行所有命令，所以他有 root 权限。

请注意，运行 `sudo -l` 命令可能需要你输入当前用户的密码。
# 一些命令
## ps  -aux  | grep 8659 
```bash
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 16:20:17 11] $ echo $$
8659
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 16:20:58 12] $ pstree -p | grep 8659
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 16:21:04 13] $ ps  -aux  | grep 8659
USER202+  8659  0.0  0.0  10036  5084 pts/7    S    16:16   0:00 -bash
USER202+  9688  0.0  0.0   8168   656 pts/7    S+   16:21   0:00 grep --color=auto 8659
```
你运行的 `ps -aux | grep 8659` 命令是在所有当前运行的进程中查找 PID 为 8659 的进程。

从你的输出中可以看到，有两个进程的信息被列出：

1. PID 为 8659 的进程，这是一个 bash shell 进程，它在 pts/7 终端上运行，由 USER202+ 用户启动。

2. PID 为 9688 的进程，这是你刚刚运行的 `grep` 命令，它在查找包含 "8659" 的行。

所以，PID 为 8659 的进程是一个 bash shell 进程，由 USER202+ 用户在 pts/7 终端上启动的。

你提到的 `ps -aux | grep 8659` 命令实际上是两个命令的组合。

1. `ps -aux`：这个命令的全称是 "process status"。它用于显示系统中的进程状态。`-aux` 是这个命令的选项，其中：
   - `a` 表示显示所有用户的进程；
   - `u` 表示以用户为中心的格式显示进程信息；
   - `x` 表示显示没有控制终端的进程。

2. `grep 8659`：这个命令的全称是 "global regular expression print"。它用于在输入中搜索匹配特定模式的行。在这个命令中，`8659` 是要搜索的模式，所以 `grep 8659` 会输出包含 "8659" 的行。

`|` 是一个管道符，它将前一个命令的输出作为后一个命令的输入。所以，`ps -aux | grep 8659` 命令的作用是在所有进程的信息中搜索 PID 为 8659 的进程。
## 使用pstree -p | grep 8659和pstree -p | grep $$没反应
如果你在运行 `pstree -p | grep $$` 命令时没有任何输出，那可能是因为你的 shell 进程在 pstree 的输出中没有被列出。这可能是因为 pstree 默认只显示那些有子进程的进程，而你的 shell 进程可能没有任何子进程。

你可以尝试使用 `ps -p $$` 命令来查看你的 shell 进程的状态。这个命令会显示 PID 为 $$ 的进程的详细信息。

如果你想在 pstree 的输出中看到你的 shell 进程，你可以尝试在你的 shell 进程中启动一个子进程，然后再运行 `pstree -p | grep $$` 命令。例如，你可以运行 `sleep 60 &` 命令来启动一个在后台运行 60 秒的子进程，然后再运行 `pstree -p | grep $$` 命令。

按照这个操作执行后还是没反应

这个问题可能是由于 `pstree` 命令的输出没有包含所有的进程，或者 `grep` 命令没有正确地匹配到你的 shell 进程。

你可以尝试直接运行 `pstree -p` 命令，然后手动在输出中查找你的 shell 进程。你的 shell 进程的 PID 是 $$，所以你应该在输出中查找这个数字。

另外，你也可以尝试使用 `pgrep` 命令来查找你的 shell 进程。`pgrep` 命令可以在运行的进程中查找匹配特定模式的进程。你可以运行 `pgrep -fl $$` 命令，这个命令会在运行的进程中查找 PID 为 $$ 的进程，并显示这个进程的详细信息。

你运行的 `pgrep -fl $$` 命令是用来查找 PID 为 $$ 的进程的。在这个命令中，`$$` 是一个特殊的 shell 变量，它代表当前 shell 的 PID。

然而，从你的输出中可以看到，这个命令并没有找到任何匹配的进程。这可能是因为你的 shell 进程在运行 `pgrep -fl $$` 命令时已经结束，或者 `pgrep` 命令没有正确地匹配到你的 shell 进程。

你可以尝试再次运行你的程序，然后立即运行 `pgrep -fl $$` 命令，看看是否能找到你的进程。如果你的程序是一个长时间运行的进程，那么你应该能在运行的进程中看到它。

另外，你的输出中的 `[1]+ Done sleep 60` 表示你之前在后台启动的 `sleep 60` 命令已经完成。这个信息是由你的 shell 自动输出的，它表示你的后台进程的状态已经改变。

# 为什么我在vscode创建的文件默认权限都是root，我想把默认权限改为USER2022100821
在 Linux 系统中，新创建的文件的所有者默认是创建该文件的用户。如果你在 VS Code 中创建的文件的所有者是 root，那可能是因为你以 root 用户身份运行了 VS Code。

你可以通过以下步骤更改文件的所有者：

1. 打开一个终端。
2. 使用 `chown` 命令更改文件的所有者。例如，如果你想将文件的所有者更改为 USER2022100821，你可以运行以下命令：

```bash
sudo chown USER2022100821 filename
```

在这个命令中，你需要将 `filename` 替换为你想更改的文件的路径。

为了避免以后创建的文件仍然属于 root，你应该以你自己的用户身份运行 VS Code，而不是以 root 用户身份运行。你可以通过在终端中输入 `code` 命令来以你自己的用户身份启动 VS Code。

>我怎么看当前终端是属于哪个用户
在 Linux 系统中，你可以使用 `whoami` 命令来查看当前终端的用户。这个命令会打印出当前用户的用户名。

在你的终端中输入以下命令，然后按回车键：

```bash
whoami
```

这个命令会返回当前用户的用户名。如果你以 root 用户身份运行了终端，那么这个命令会返回 "root"。如果你以其他用户身份运行了终端，那么这个命令会返回那个用户的用户名。
```bash
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 17:21:02 74] $ ls -l
total 172
-rw-r--r-- 1 root root  8044 Mar 29 15:08 523hz8k8bit.wav
-rw-r--r-- 1 root root  8233 Mar 29 16:43 learn.md
-rwxr-xr-x 1 root root 16880 Mar 29 17:18 testid
-rw-r--r-- 1 root root   152 Mar 29 17:16 testid.c
-rwxr-xr-x 1 root root 16968 Mar 29 15:51 wav
-rw-r--r-- 1 root root   754 Mar 29 15:51 wav.c
-rwxr-xr-x 1 root root 17144 Mar 29 16:01 wav2
-rw-r--r-- 1 root root  1164 Mar 29 16:01 wav2.c
-rw-r--r-- 1 root root 79977 Mar 29 15:13 命令.md
```
怎么把当下文件夹的所有文件权限全改为USER2022100821

在 Linux 系统中，你可以使用 `chown` 命令来更改文件或目录的所有者。如果你想将当前目录下的所有文件和子目录的所有者更改为 USER2022100821，你可以使用 `-R` 参数（表示递归）并使用通配符 `*`（表示所有文件和目录）。

在你的终端中输入以下命令，然后按回车键：

```bash
sudo chown -R USER2022100821 *
```

这个命令会将当前目录下的所有文件和子目录的所有者更改为 USER2022100821。请注意，由于这个操作可能需要管理员权限，所以你可能需要在命令前面加上 `sudo`。

如果你只想更改文件的所有者，而不更改目录的所有者，你可以使用 `find` 命令：

```bash
sudo find . -type f -exec chown USER2022100821 {} \;
```

这个命令会找到当前目录及其子目录下的所有文件，并将它们的所有者更改为 USER2022100821。

```bash
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 17:24:07 79] $ sudo chown -R USER2022100821:USER2022100821 *
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 17:24:10 80] $ ls -l
total 172
-rw-r--r-- 1 USER2022100821 USER2022100821  8044 Mar 29 15:08 523hz8k8bit.wav
-rw-r--r-- 1 USER2022100821 USER2022100821  8233 Mar 29 16:43 learn.md
-rwxr-xr-x 1 USER2022100821 USER2022100821 16880 Mar 29 17:18 testid
-rw-r--r-- 1 USER2022100821 USER2022100821   152 Mar 29 17:16 testid.c
-rwxr-xr-x 1 USER2022100821 USER2022100821 16968 Mar 29 15:51 wav
-rw-r--r-- 1 USER2022100821 USER2022100821   754 Mar 29 15:51 wav.c
-rwxr-xr-x 1 USER2022100821 USER2022100821 17144 Mar 29 16:01 wav2
-rw-r--r-- 1 USER2022100821 USER2022100821  1164 Mar 29 16:01 wav2.c
-rw-r--r-- 1 USER2022100821 USER2022100821 79977 Mar 29 15:13 命令.md
```


在你的输出中，"USER2022100821" 是文件的所有者，而 "root" 是文件的组。这意味着这些文件的所有者已经被成功更改为 "USER2022100821"，但是这些文件仍然属于 "root" 组。

如果你想将这些文件的组也更改为 "USER2022100821"，你可以使用 `chown` 命令的 `user:group` 语法。在你的终端中输入以下命令，然后按回车键：

```bash
sudo chown -R USER2022100821:USER2022100821 *
```

这个命令会将当前目录下的所有文件和子目录的所有者和组都更改为 "USER2022100821"。

```bash
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 17:24:07 79] $ sudo chown -R USER2022100821:USER2022100821 *
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 17:24:10 80] $ ls -l
total 172
-rw-r--r-- 1 USER2022100821 USER2022100821  8044 Mar 29 15:08 523hz8k8bit.wav
-rw-r--r-- 1 USER2022100821 USER2022100821  8233 Mar 29 16:43 learn.md
-rwxr-xr-x 1 USER2022100821 USER2022100821 16880 Mar 29 17:18 testid
-rw-r--r-- 1 USER2022100821 USER2022100821   152 Mar 29 17:16 testid.c
-rwxr-xr-x 1 USER2022100821 USER2022100821 16968 Mar 29 15:51 wav
-rw-r--r-- 1 USER2022100821 USER2022100821   754 Mar 29 15:51 wav.c
-rwxr-xr-x 1 USER2022100821 USER2022100821 17144 Mar 29 16:01 wav2
-rw-r--r-- 1 USER2022100821 USER2022100821  1164 Mar 29 16:01 wav2.c
-rw-r--r-- 1 USER2022100821 USER2022100821 79977 Mar 29 15:13 命令.md
```

## 为什么我在vscode侧边栏新建了文本文件，权限仍然是root的，我刚才已经把终端改成USER2022100821了

VS Code 会以启动它的用户身份来创建新的文件。如果你以 root 用户身份启动了 VS Code，那么 VS Code 创建的新文件的所有者将会是 root，即使你已经在终端中切换到了其他用户。

为了解决这个问题，你需要以你自己的用户身份启动 VS Code。你可以通过在终端中输入 `code` 命令来以你自己的用户身份启动 VS Code。如果你已经以 root 用户身份启动了 VS Code，你可能需要先关闭它，然后再以你自己的用户身份重新启动它。

如果你已经以你自己的用户身份启动了 VS Code，但是新创建的文件的所有者仍然是 root，那可能是因为你的系统设置了某些特殊的权限规则。在这种情况下，你可能需要查看你的系统文档，或者联系你的系统管理员以获取帮助。

# pid，ppid，uid，gid
这段 C 语言代码的功能是打印出当前进程的 PID（进程 ID）、PPID（父进程 ID）、UID（用户 ID）和 GID（组 ID）。

代码解析如下：

- `getpid()` 函数返回当前进程的 PID。
- `getppid()` 函数返回父进程的 PID。
- `getuid()` 函数返回当前用户的 UID。
- `getgid()` 函数返回当前用户的 GID。

这些信息对于理解进程的运行环境和权限非常有用。例如，UID 和 GID 可以用来确定进程有哪些系统资源的访问权限。

这些 ID 都是在 Unix 和类 Unix 系统（如 Linux）中用于标识进程和用户的唯一标识符。

- PID（Process ID）：这是进程的唯一标识符。每个进程在系统中都有一个唯一的 PID。
- PPID（Parent Process ID）：这是创建当前进程的进程的 PID。也就是说，它是当前进程的父进程的 PID。
- UID（User ID）：这是用户的唯一标识符。在 Unix 系统中，每个用户都有一个唯一的 UID。系统通过 UID 来识别用户，并控制用户的访问权限。例如，UID 为 0 的用户通常是 root 用户，拥有最高的权限。
- GID（Group ID）：这是用户组的唯一标识符。在 Unix 系统中，每个用户都属于至少一个用户组，每个用户组都有一个唯一的 GID。系统通过 GID 来识别用户组，并控制用户组的访问权限。

UID 和 GID 是 Unix 权限管理的基础。每个文件都有一个所有者（UID）和一个所属的用户组（GID）。文件的权限设置决定了哪些用户（UID）和用户组（GID）可以访问（读、写、执行）这个文件。

```bash
[USER2022100821@Y7000P ~/work/Linux_homework/homework4 03.29 17:26:18 84] $ ./testid
pid:19667, ppid:8659, uid:1000, gid:1000
```
在 Linux 系统中，每个用户都有一个唯一的用户 ID（UID），每个用户组都有一个唯一的组 ID（GID）。这些 ID 用于识别用户和用户组，并控制他们的访问权限。

当你在 Linux 系统中创建一个新用户时，系统会自动分配一个 UID 和 GID。在许多 Linux 发行版中，第一个创建的非 root 用户的 UID 和 GID 通常会被设置为 1000。所以，如果你的 UID 和 GID 都是 1000，那可能是因为你是在系统中创建的第一个非 root 用户。

请注意，不同的系统可能会有不同的 UID 和 GID 分配规则。在一些系统中，第一个创建的非 root 用户的 UID 和 GID 可能不是 1000。

